# 8.2 Shared Hooks Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Create reusable hooks for debouncing values and haptic feedback across web and mobile platforms.

**Architecture:** `useDebounce` is a platform-agnostic React hook placed in both web and mobile. `useHaptics` is mobile-only, wrapping expo-haptics with a convenient API. Both follow React conventions and the existing hook patterns in the codebase.

**Tech Stack:** React 19, TypeScript, expo-haptics (mobile only)

---

## Prerequisites

- expo-haptics is already installed in klard-mobile (Expo SDK 54 includes it)
- Hooks use existing naming conventions: camelCase for mobile (`useDebounce`), kebab-case files for web (`use-debounce.ts`)

---

## SOLID Compliance

| Component | SRP | OCP | LSP | ISP | DIP |
|-----------|-----|-----|-----|-----|-----|
| useDebounce | Debounces values only | Configurable delay | Returns same type as input | Single hook | No external deps |
| useHaptics | Provides haptic methods only | Extensible return object | N/A | Focused interface | Depends on expo-haptics abstraction |

---

## Part A: useDebounce Hook (Both Platforms)

---

## Task 1: Write failing test for useDebounce (Web)

**Files:**
- Create: `klard-web/src/__tests__/hooks/use-debounce.test.ts`

**Step 1: Write the failing test**

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { renderHook, act } from '@testing-library/react';
import { useDebounce } from '@/hooks/use-debounce';

describe('useDebounce', () => {
  beforeEach(() => {
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it('returns initial value immediately', () => {
    const { result } = renderHook(() => useDebounce('initial', 500));
    expect(result.current).toBe('initial');
  });

  it('does not update value before delay', () => {
    const { result, rerender } = renderHook(
      ({ value, delay }) => useDebounce(value, delay),
      { initialProps: { value: 'initial', delay: 500 } }
    );

    rerender({ value: 'updated', delay: 500 });

    // Advance time but not enough
    act(() => {
      vi.advanceTimersByTime(300);
    });

    expect(result.current).toBe('initial');
  });

  it('updates value after delay', () => {
    const { result, rerender } = renderHook(
      ({ value, delay }) => useDebounce(value, delay),
      { initialProps: { value: 'initial', delay: 500 } }
    );

    rerender({ value: 'updated', delay: 500 });

    act(() => {
      vi.advanceTimersByTime(500);
    });

    expect(result.current).toBe('updated');
  });

  it('cancels previous timeout on rapid changes', () => {
    const { result, rerender } = renderHook(
      ({ value, delay }) => useDebounce(value, delay),
      { initialProps: { value: 'first', delay: 500 } }
    );

    rerender({ value: 'second', delay: 500 });
    act(() => {
      vi.advanceTimersByTime(200);
    });

    rerender({ value: 'third', delay: 500 });
    act(() => {
      vi.advanceTimersByTime(200);
    });

    // Still showing first because third's timer hasn't elapsed
    expect(result.current).toBe('first');

    act(() => {
      vi.advanceTimersByTime(300);
    });

    // Now shows third (skipped second)
    expect(result.current).toBe('third');
  });

  it('works with different types', () => {
    const { result, rerender } = renderHook(
      ({ value, delay }) => useDebounce(value, delay),
      { initialProps: { value: 42, delay: 300 } }
    );

    rerender({ value: 100, delay: 300 });

    act(() => {
      vi.advanceTimersByTime(300);
    });

    expect(result.current).toBe(100);
  });

  it('cleans up timeout on unmount', () => {
    const clearTimeoutSpy = vi.spyOn(global, 'clearTimeout');
    const { unmount } = renderHook(() => useDebounce('value', 500));

    unmount();

    expect(clearTimeoutSpy).toHaveBeenCalled();
    clearTimeoutSpy.mockRestore();
  });
});
```

**Step 2: Run test to verify it fails**

Run: `pnpm --filter klard-web test src/__tests__/hooks/use-debounce.test.ts --run`
Expected: FAIL with "Cannot find module '@/hooks/use-debounce'"

---

## Task 2: Implement useDebounce (Web)

**Files:**
- Create: `klard-web/src/hooks/use-debounce.ts`

**Step 1: Write minimal implementation**

```typescript
'use client';

import { useState, useEffect } from 'react';

/**
 * Debounces a value by the specified delay
 *
 * @param value - The value to debounce
 * @param delay - Delay in milliseconds
 * @returns The debounced value
 *
 * @example
 * const debouncedSearch = useDebounce(searchTerm, 300);
 */
export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}
```

**Step 2: Run test to verify it passes**

Run: `pnpm --filter klard-web test src/__tests__/hooks/use-debounce.test.ts --run`
Expected: PASS

**Step 3: Commit**

```bash
git add klard-web/src/hooks/use-debounce.ts klard-web/src/__tests__/hooks/use-debounce.test.ts
git commit -m "feat(web): add useDebounce hook"
```

---

## Task 3: Write failing test for useDebounce (Mobile)

**Files:**
- Create: `klard-mobile/src/__tests__/hooks/useDebounce.test.ts`

**Step 1: Write the failing test**

```typescript
import { describe, it, expect, jest, beforeEach, afterEach } from '@jest/globals';
import { renderHook, act } from '@testing-library/react-native';
import { useDebounce } from '@/hooks/useDebounce';

describe('useDebounce', () => {
  beforeEach(() => {
    jest.useFakeTimers();
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  it('returns initial value immediately', () => {
    const { result } = renderHook(() => useDebounce('initial', 500));
    expect(result.current).toBe('initial');
  });

  it('does not update value before delay', () => {
    const { result, rerender } = renderHook(
      ({ value, delay }) => useDebounce(value, delay),
      { initialProps: { value: 'initial', delay: 500 } }
    );

    rerender({ value: 'updated', delay: 500 });

    act(() => {
      jest.advanceTimersByTime(300);
    });

    expect(result.current).toBe('initial');
  });

  it('updates value after delay', () => {
    const { result, rerender } = renderHook(
      ({ value, delay }) => useDebounce(value, delay),
      { initialProps: { value: 'initial', delay: 500 } }
    );

    rerender({ value: 'updated', delay: 500 });

    act(() => {
      jest.advanceTimersByTime(500);
    });

    expect(result.current).toBe('updated');
  });

  it('cancels previous timeout on rapid changes', () => {
    const { result, rerender } = renderHook(
      ({ value, delay }) => useDebounce(value, delay),
      { initialProps: { value: 'first', delay: 500 } }
    );

    rerender({ value: 'second', delay: 500 });
    act(() => {
      jest.advanceTimersByTime(200);
    });

    rerender({ value: 'third', delay: 500 });
    act(() => {
      jest.advanceTimersByTime(200);
    });

    expect(result.current).toBe('first');

    act(() => {
      jest.advanceTimersByTime(300);
    });

    expect(result.current).toBe('third');
  });

  it('works with number type', () => {
    const { result, rerender } = renderHook(
      ({ value, delay }) => useDebounce(value, delay),
      { initialProps: { value: 42, delay: 300 } }
    );

    rerender({ value: 100, delay: 300 });

    act(() => {
      jest.advanceTimersByTime(300);
    });

    expect(result.current).toBe(100);
  });
});
```

**Step 2: Run test to verify it fails**

Run: `pnpm --filter klard-mobile test src/__tests__/hooks/useDebounce.test.ts --run`
Expected: FAIL with "Cannot find module '@/hooks/useDebounce'"

---

## Task 4: Implement useDebounce (Mobile)

**Files:**
- Create: `klard-mobile/src/hooks/useDebounce.ts`

**Step 1: Write minimal implementation**

```typescript
import { useState, useEffect } from 'react';

/**
 * Debounces a value by the specified delay
 *
 * @param value - The value to debounce
 * @param delay - Delay in milliseconds
 * @returns The debounced value
 *
 * @example
 * const debouncedSearch = useDebounce(searchTerm, 300);
 */
export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}
```

**Step 2: Run test to verify it passes**

Run: `pnpm --filter klard-mobile test src/__tests__/hooks/useDebounce.test.ts --run`
Expected: PASS

**Step 3: Export from hooks index**

Update `klard-mobile/src/hooks/index.ts` (create if doesn't exist):

```typescript
export { useDebounce } from './useDebounce';
export { useThemeColors } from './useThemeColors';
export { useOnboarding } from './useOnboarding';
export { useAuthRedirect } from './useAuthRedirect';
```

**Step 4: Commit**

```bash
git add klard-mobile/src/hooks/useDebounce.ts klard-mobile/src/__tests__/hooks/useDebounce.test.ts klard-mobile/src/hooks/index.ts
git commit -m "feat(mobile): add useDebounce hook"
```

---

## Part B: useHaptics Hook (Mobile Only)

---

## Task 5: Write failing test for useHaptics

**Files:**
- Create: `klard-mobile/src/__tests__/hooks/useHaptics.test.ts`

**Step 1: Write the failing test**

```typescript
import { describe, it, expect, jest, beforeEach } from '@jest/globals';
import { renderHook } from '@testing-library/react-native';
import * as Haptics from 'expo-haptics';
import { useHaptics } from '@/hooks/useHaptics';

// Mock expo-haptics
jest.mock('expo-haptics', () => ({
  impactAsync: jest.fn(),
  notificationAsync: jest.fn(),
  selectionAsync: jest.fn(),
  ImpactFeedbackStyle: {
    Light: 'light',
    Medium: 'medium',
    Heavy: 'heavy',
    Rigid: 'rigid',
    Soft: 'soft',
  },
  NotificationFeedbackType: {
    Success: 'success',
    Warning: 'warning',
    Error: 'error',
  },
}));

describe('useHaptics', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('returns all haptic methods', () => {
    const { result } = renderHook(() => useHaptics());

    expect(result.current).toHaveProperty('light');
    expect(result.current).toHaveProperty('medium');
    expect(result.current).toHaveProperty('heavy');
    expect(result.current).toHaveProperty('rigid');
    expect(result.current).toHaveProperty('soft');
    expect(result.current).toHaveProperty('success');
    expect(result.current).toHaveProperty('warning');
    expect(result.current).toHaveProperty('error');
    expect(result.current).toHaveProperty('selection');
  });

  it('calls impactAsync with Light style', async () => {
    const { result } = renderHook(() => useHaptics());
    await result.current.light();
    expect(Haptics.impactAsync).toHaveBeenCalledWith(Haptics.ImpactFeedbackStyle.Light);
  });

  it('calls impactAsync with Medium style', async () => {
    const { result } = renderHook(() => useHaptics());
    await result.current.medium();
    expect(Haptics.impactAsync).toHaveBeenCalledWith(Haptics.ImpactFeedbackStyle.Medium);
  });

  it('calls impactAsync with Heavy style', async () => {
    const { result } = renderHook(() => useHaptics());
    await result.current.heavy();
    expect(Haptics.impactAsync).toHaveBeenCalledWith(Haptics.ImpactFeedbackStyle.Heavy);
  });

  it('calls impactAsync with Rigid style', async () => {
    const { result } = renderHook(() => useHaptics());
    await result.current.rigid();
    expect(Haptics.impactAsync).toHaveBeenCalledWith(Haptics.ImpactFeedbackStyle.Rigid);
  });

  it('calls impactAsync with Soft style', async () => {
    const { result } = renderHook(() => useHaptics());
    await result.current.soft();
    expect(Haptics.impactAsync).toHaveBeenCalledWith(Haptics.ImpactFeedbackStyle.Soft);
  });

  it('calls notificationAsync with Success type', async () => {
    const { result } = renderHook(() => useHaptics());
    await result.current.success();
    expect(Haptics.notificationAsync).toHaveBeenCalledWith(Haptics.NotificationFeedbackType.Success);
  });

  it('calls notificationAsync with Warning type', async () => {
    const { result } = renderHook(() => useHaptics());
    await result.current.warning();
    expect(Haptics.notificationAsync).toHaveBeenCalledWith(Haptics.NotificationFeedbackType.Warning);
  });

  it('calls notificationAsync with Error type', async () => {
    const { result } = renderHook(() => useHaptics());
    await result.current.error();
    expect(Haptics.notificationAsync).toHaveBeenCalledWith(Haptics.NotificationFeedbackType.Error);
  });

  it('calls selectionAsync', async () => {
    const { result } = renderHook(() => useHaptics());
    await result.current.selection();
    expect(Haptics.selectionAsync).toHaveBeenCalled();
  });

  it('returns stable references', () => {
    const { result, rerender } = renderHook(() => useHaptics());
    const firstResult = result.current;

    rerender({});

    expect(result.current.light).toBe(firstResult.light);
    expect(result.current.success).toBe(firstResult.success);
  });
});
```

**Step 2: Run test to verify it fails**

Run: `pnpm --filter klard-mobile test src/__tests__/hooks/useHaptics.test.ts --run`
Expected: FAIL with "Cannot find module '@/hooks/useHaptics'"

---

## Task 6: Implement useHaptics

**Files:**
- Create: `klard-mobile/src/hooks/useHaptics.ts`

**Step 1: Write minimal implementation**

```typescript
import { useCallback, useMemo } from 'react';
import * as Haptics from 'expo-haptics';

/**
 * Hook providing convenient haptic feedback methods
 *
 * @returns Object with methods for different haptic feedback types
 *
 * @example
 * const haptics = useHaptics();
 * haptics.light(); // Light impact
 * haptics.success(); // Success notification
 */
export function useHaptics() {
  const light = useCallback(
    () => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light),
    []
  );

  const medium = useCallback(
    () => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium),
    []
  );

  const heavy = useCallback(
    () => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy),
    []
  );

  const rigid = useCallback(
    () => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Rigid),
    []
  );

  const soft = useCallback(
    () => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Soft),
    []
  );

  const success = useCallback(
    () => Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success),
    []
  );

  const warning = useCallback(
    () => Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning),
    []
  );

  const error = useCallback(
    () => Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error),
    []
  );

  const selection = useCallback(() => Haptics.selectionAsync(), []);

  return useMemo(
    () => ({
      light,
      medium,
      heavy,
      rigid,
      soft,
      success,
      warning,
      error,
      selection,
    }),
    [light, medium, heavy, rigid, soft, success, warning, error, selection]
  );
}
```

**Step 2: Run test to verify it passes**

Run: `pnpm --filter klard-mobile test src/__tests__/hooks/useHaptics.test.ts --run`
Expected: PASS

**Step 3: Export from hooks index**

Update `klard-mobile/src/hooks/index.ts`:

```typescript
export { useDebounce } from './useDebounce';
export { useHaptics } from './useHaptics';
export { useThemeColors } from './useThemeColors';
export { useOnboarding } from './useOnboarding';
export { useAuthRedirect } from './useAuthRedirect';
```

**Step 4: Commit**

```bash
git add klard-mobile/src/hooks/useHaptics.ts klard-mobile/src/__tests__/hooks/useHaptics.test.ts klard-mobile/src/hooks/index.ts
git commit -m "feat(mobile): add useHaptics hook"
```

---

## Task 7: Create web hooks index file

**Files:**
- Create/Update: `klard-web/src/hooks/index.ts`

**Step 1: Create hooks index**

```typescript
export { useDebounce } from './use-debounce';
export { useAuthError } from './use-auth-error';
export { useOnboarding } from './use-onboarding';
export { useAuthRedirect } from './use-auth-redirect';
```

**Step 2: Commit**

```bash
git add klard-web/src/hooks/index.ts
git commit -m "feat(web): add hooks index file"
```

---

## Task 8: Verify builds and type-check

**Files:**
- All hook files

**Step 1: Type check web**

Run: `pnpm --filter klard-web exec tsc --noEmit`
Expected: No type errors

**Step 2: Type check mobile**

Run: `pnpm --filter klard-mobile exec tsc --noEmit`
Expected: No type errors

**Step 3: Run all web tests**

Run: `pnpm --filter klard-web test --run`
Expected: All tests pass

**Step 4: Run all mobile tests**

Run: `pnpm --filter klard-mobile test --run`
Expected: All tests pass

**Step 5: Final commit**

```bash
git add -A
git commit -m "feat: complete shared hooks implementation"
```

---

## Task 9: Mark spec as DONE

**Files:**
- Modify: `docs/screens/batch/Klard_Component_Specifications.md`

**Step 1: Update spec marker**

Find: `<!-- SECTION:START:8.2-shared-hooks -->`
Add after: `<!-- DONE:8.2-shared-hooks -->`

**Step 2: Commit**

```bash
git add docs/screens/batch/Klard_Component_Specifications.md
git commit -m "docs: mark 8.2-shared-hooks as DONE"
```

---

## Verification Checklist

- [ ] useDebounce implemented for web
- [ ] useDebounce implemented for mobile
- [ ] useHaptics implemented for mobile (with expo-haptics)
- [ ] All tests pass for web
- [ ] All tests pass for mobile
- [ ] TypeScript compiles without errors (web)
- [ ] TypeScript compiles without errors (mobile)
- [ ] Hooks exported from index files
- [ ] Spec marked as DONE