# 3.7 Stepper / Progress Indicator Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Deliver a reusable Stepper/Progress Indicator for web and mobile that visualizes multi-step flows with completed/current/upcoming states, horizontal and vertical orientations, optional descriptions, accessible semantics, and Klard design tokens, with strict TDD.

**Architecture:** Build platform-specific presentational components consuming step data. Web leverages shadcn/ui primitives, Tailwind classes, and CVA variant system for orientation and status. Mobile uses React Native primitives with StyleSheet and Expo icons. Keep logic minimal: derive statuses from `currentStep` and render indicators/connectors accordingly. Provide optional descriptions below labels. Expose orientation on web and mobile (mobile defaults vertical with horizontal available when width allows). Support RTL mirroring and screen reader semantics. No navigation logic inside; parent controls `currentStep`.

**Tech Stack:** Next.js 16 App Router + React 19 + shadcn/ui + Tailwind CSS 4 + class-variance-authority; lucide-react icons; Expo 54 + React Native + `@expo/vector-icons/Ionicons`; `react-native-safe-area-context` for spacing; Vitest + Testing Library (web); jest-expo + React Native Testing Library (mobile).

---

## SOLID Compliance

| Component | SRP | OCP | LSP | ISP | DIP |
|-----------|-----|-----|-----|-----|-----|
| Stepper (Web) | Renders step progress only | Extensible via orientation prop | Handles all step states | Single StepperProps interface | Depends on Step type abstraction |
| Stepper (Mobile) | Renders step progress only | Extensible via orientation prop | Handles all step states | Single StepperProps interface | Depends on Step type abstraction, useThemeColors hook |
| StepCircle | Renders single step indicator | State-driven via props | N/A (leaf component) | Minimal props interface | Depends on state abstraction |

### SOLID Principle Applications (Detailed)

**Single Responsibility Principle (SRP):**
- Stepper only visualizes progress; no navigation, no state changes, no business logic
- Each component has one reason to change: visual representation updates

**Open/Closed Principle (OCP):**
- Extend via props (orientation, statuses, ariaLabel) without code changes
- New states can be added by extending the StepState type and variant mappings

**Liskov Substitution Principle (LSP):**
- Any Stepper usage can substitute derived vs explicit statuses without breaking contract
- All step states (completed, current, upcoming) handled consistently

**Interface Segregation Principle (ISP):**
- Props only include step display concerns; no unrelated config
- Single focused interface with only necessary props

**Dependency Inversion Principle (DIP):**
- Depends on abstractions (steps array, status enum) not on concrete data sources
- Mobile depends on useThemeColors hook, not hardcoded theme values

---

## Props Interface

```typescript
interface Step {
  label: string;
  description?: string;
  status?: 'completed' | 'current' | 'upcoming'; // Optional explicit status
}

interface StepperProps {
  steps: Step[];
  currentStep: number; // 0-indexed
  orientation?: 'horizontal' | 'vertical';
  ariaLabel?: string; // Web only - custom accessibility label
  accessibilityLabel?: string; // Mobile only - custom accessibility label
  className?: string; // Web only
  style?: StyleProp<ViewStyle>; // Mobile only
}
```

---

## Visual States

| State | Circle Style | Label Style | Connector Style |
|-------|--------------|-------------|-----------------|
| Completed | bg-teal-600 dark:bg-teal-500, white checkmark | text-slate-900 dark:text-slate-100 | bg-teal-600 dark:bg-teal-500 |
| Active/Current | bg-teal-600 dark:bg-teal-500, white number, ring-4 ring-teal-100 dark:ring-teal-900 | text-slate-900 dark:text-slate-100 font-medium | bg-slate-200 dark:bg-slate-700 |
| Upcoming/Pending | bg-slate-200 dark:bg-slate-700, text-slate-500 dark:text-slate-400 | text-slate-500 dark:text-slate-400 | bg-slate-200 dark:bg-slate-700 |

---

## Color Tokens

### Web (Tailwind Classes)
- **Primary (Teal)**: `bg-teal-600` (light: #0D7C7A), `dark:bg-teal-500` (dark: #15B5B0)
- **Muted**: `bg-slate-200` (light: #E2E8F0), `dark:bg-slate-700`
- **Text Active**: `text-slate-900` (light: #0F172A), `dark:text-slate-100` (dark: #F8FAFC)
- **Text Muted**: `text-slate-500` (light: #64748B), `dark:text-slate-400` (dark: #94A3B8)

### Mobile (StyleSheet)
- **Primary**: `#0D7C7A` (light), `#15B5B0` (dark via theme hook)
- **Muted Background**: `#E2E8F0`
- **Text Primary**: `#0F172A` (via theme hook)
- **Text Secondary**: `#64748B` (via theme hook)
- **White**: `#FFFFFF` (for completed/active circle text)

---

## Size Specifications

- **Circle Size**: 32px (h-8 w-8 on web; width: 32, height: 32 on mobile)
- **Circle Font**: text-sm font-medium (14px, weight 500)
- **Icon Size**: 16px (h-4 w-4 Check icon on web; size={16} Ionicons on mobile)
- **Gap between circle and label**: 8px (horizontal), 12px (vertical on mobile)
- **Connector thickness**: 2px (h-0.5 on web horizontal; height: 2 on mobile horizontal)
- **Connector spacing**: 16px horizontal margin (mx-4 on web), 15px left margin for vertical
- **Ring thickness**: 4px ring (ring-4 on web), shadow/elevation on mobile

---

## Accessibility Details

### Web Accessibility
- **Container**: `role="list"` with `aria-label={ariaLabel ?? 'Progress'}`
- **Each step**: `role="listitem"`
- **Current step**: `aria-current="step"`
- **Connectors**: `aria-hidden="true"` (decorative)
- **Icons**: `aria-hidden="true"` (status conveyed via aria-current and data-state)
- **Data attributes**: `data-slot="stepper"`, `data-state="completed|current|upcoming"` per step

### Mobile Accessibility
- **Container**: `accessibilityRole="progressbar"`
- **Accessibility value**: `{ now: currentStep + 1, min: 1, max: steps.length, text: 'Step X of Y' }`
- **Each step**: `accessibilityRole="text"`, `accessibilityState={{ selected: state === 'current' }}`
- **Accessibility label format**: `"Step ${index+1} of ${steps.length}: ${label}${description ? ', ' + description : ''}${statusText}"`
  - Completed: "Step 1 of 4: Account, completed."
  - Current: "Step 2 of 4: Billing, in progress."
  - Upcoming: "Step 3 of 4: Confirm, not started."

---

## Requirements & Behavior

### Derived Status Logic
- If `step.status` provided, use it; otherwise derive:
  - `index < currentStep` => `completed`
  - `index === currentStep` => `current`
  - `index > currentStep` => `upcoming`

### Guardrails
- Clamp `currentStep` to `[0, steps.length - 1]` for rendering (do not mutate prop)
- If `steps.length === 0`: return null and warn in dev
- If `currentStep < 0`: clamp to 0
- If `currentStep >= steps.length`: clamp to last index

### Orientation Handling
- **Web**: `orientation` prop controls flex-direction; default `horizontal`
- **Mobile**: `orientation` prop controls flex-direction; default `horizontal` (matching web for consistency)
- Horizontal: connectors stretch flex-1 between steps
- Vertical: connectors span vertically with fixed height, aligned with circle centers

### Labels & Descriptions
- **Label**: Required string; wrap text for long labels; semantic color based on state
- **Description**: Optional smaller text; clamp to 2 lines; muted color; fontSize 12px

### Connectors
- **Horizontal**: Line with `flex-1` width, 2px height, color based on preceding step state
- **Vertical**: Line with 2px width, fixed height (32px mobile, h-8 web), color based on preceding step state
- **Color logic**: `preceding step completed` → primary color; else → muted color

### RTL Support
- **Web**: Rely on CSS `direction` property; ensure symmetric margins
- **Mobile**: Use symmetric padding; React Native handles RTL mirroring automatically

---

## Test Strategy

Tests will be written FIRST following TDD:
1. **Rendering tests** - component mounts with required props
2. **Step state tests** - completed/active/pending states render correctly
3. **Orientation tests** - horizontal/vertical layouts
4. **Accessibility tests** - proper ARIA attributes and roles
5. **Edge case tests** - single step, all completed, none completed
6. **Connector tests** - count and color based on completion state
7. **Custom props tests** - className merging, custom aria labels

### Extended Test Case Matrix (Web)

**Rendering Cases:**
- W1: Renders container with correct role and aria-label
- W2: Renders all step labels and descriptions
- W3: Has data-slot="stepper" attribute

**State Cases:**
- W4: currentStep=0 → step 0 active, steps 1-2 pending
- W5: currentStep=1 → step 0 completed (with checkmark), step 1 active (with ring), step 2 pending
- W6: currentStep=2 → steps 0-1 completed, step 2 active
- W7: Explicit statuses override derived (e.g., step.status='upcoming' even when index < currentStep)

**Orientation Cases:**
- W8: Horizontal by default (flex-row class)
- W9: Vertical when orientation="vertical" (flex-col class)

**Connector Cases:**
- W10: Connector count equals steps.length - 1
- W11: Completed connectors use bg-teal-600 class
- W12: Pending connectors use bg-slate-200 class
- W13: No connector after last step

**Accessibility Cases:**
- W14: aria-current="step" only on current step
- W15: Connectors have aria-hidden="true"
- W16: Icons have aria-hidden="true"
- W17: Custom ariaLabel prop respected

**Edge Cases:**
- W18: Single step renders without connectors
- W19: Empty steps array returns null
- W20: currentStep out of range clamped correctly

### Extended Test Case Matrix (Mobile)

**Rendering Cases:**
- M1: Renders container with accessibilityRole="progressbar"
- M2: Renders all step labels and descriptions
- M3: Has correct testID="stepper-container"

**State Cases:**
- M4: currentStep=0 → step 0 active, others pending
- M5: currentStep=1 → step 0 completed (with checkmark icon), step 1 active (with testID="step-active")
- M6: Completed steps have testID="step-completed"

**Orientation Cases:**
- M7: Horizontal by default (flexDirection: 'row')
- M8: Vertical when orientation="vertical" (flexDirection: 'column')

**Connector Cases:**
- M9: Connector count equals steps.length - 1
- M10: Connectors have correct backgroundColor based on preceding step

**Accessibility Cases:**
- M11: accessibilityValue with correct now/min/max/text
- M12: Current step has accessibilityState.selected=true
- M13: Accessibility labels include step position

**Edge Cases:**
- M14: Single step renders without connectors
- M15: All steps completed shows all checkmarks

---

## Task Breakdown

### Task 1: Create Web Stepper Test File (RED)

**Files:**
- Create: `klard-web/src/__tests__/components/ui/stepper.test.tsx`

**Step 1: Write the failing tests**

```tsx
/**
 * Tests for Stepper Component
 *
 * TDD: Write failing tests first, then implement to pass.
 * Tests verify: rendering, step states, orientations, accessibility
 */

import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import { Stepper } from '@/components/ui/stepper';

const mockSteps = [
  { label: 'Step 1', description: 'First step' },
  { label: 'Step 2', description: 'Second step' },
  { label: 'Step 3', description: 'Third step' },
];

describe('Stepper', () => {
  describe('Rendering', () => {
    it('should render stepper container with list role', () => {
      render(<Stepper steps={mockSteps} currentStep={0} />);

      const stepper = screen.getByRole('list');
      expect(stepper).toBeInTheDocument();
      expect(stepper).toHaveAttribute('aria-label', 'Progress');
    });

    it('should render all step labels', () => {
      render(<Stepper steps={mockSteps} currentStep={0} />);

      expect(screen.getByText('Step 1')).toBeInTheDocument();
      expect(screen.getByText('Step 2')).toBeInTheDocument();
      expect(screen.getByText('Step 3')).toBeInTheDocument();
    });

    it('should render step descriptions', () => {
      render(<Stepper steps={mockSteps} currentStep={0} />);

      expect(screen.getByText('First step')).toBeInTheDocument();
    });

    it('should render with data-slot attribute', () => {
      const { container } = render(<Stepper steps={mockSteps} currentStep={0} />);

      const stepper = container.querySelector('[data-slot="stepper"]');
      expect(stepper).toBeInTheDocument();
    });
  });

  describe('Step States', () => {
    it('should mark completed steps with checkmark', () => {
      render(<Stepper steps={mockSteps} currentStep={2} />);

      const completedSteps = screen.getAllByTestId('step-completed');
      expect(completedSteps).toHaveLength(2);
    });

    it('should mark active step with ring and data-state', () => {
      const { container } = render(<Stepper steps={mockSteps} currentStep={1} />);

      const activeStep = container.querySelector('[data-state="current"]');
      expect(activeStep).toBeInTheDocument();
      expect(activeStep?.className).toMatch(/ring-4/);
    });

    it('should mark pending steps with number', () => {
      render(<Stepper steps={mockSteps} currentStep={0} />);

      expect(screen.getByText('2')).toBeInTheDocument();
      expect(screen.getByText('3')).toBeInTheDocument();
    });

    it('should show step 1 as active when currentStep is 0', () => {
      const { container } = render(<Stepper steps={mockSteps} currentStep={0} />);

      const activeStep = container.querySelector('[data-state="current"]');
      expect(activeStep).toHaveTextContent('1');
    });

    it('should respect explicit status prop', () => {
      const stepsWithStatus = [
        { label: 'Step 1', status: 'upcoming' as const },
        { label: 'Step 2' },
        { label: 'Step 3' },
      ];
      const { container } = render(<Stepper steps={stepsWithStatus} currentStep={2} />);

      const upcomingStep = container.querySelector('[data-state="upcoming"]');
      expect(upcomingStep).toHaveTextContent('1');
    });
  });

  describe('Orientations', () => {
    it('should render horizontal by default', () => {
      const { container } = render(<Stepper steps={mockSteps} currentStep={0} />);

      const stepper = container.querySelector('[data-slot="stepper"]');
      expect(stepper?.className).toMatch(/flex-row/);
    });

    it('should render vertical when orientation is vertical', () => {
      const { container } = render(
        <Stepper steps={mockSteps} currentStep={0} orientation="vertical" />
      );

      const stepper = container.querySelector('[data-slot="stepper"]');
      expect(stepper?.className).toMatch(/flex-col/);
    });
  });

  describe('Connectors', () => {
    it('should render connectors between steps in horizontal mode', () => {
      const { container } = render(<Stepper steps={mockSteps} currentStep={0} />);

      const connectors = container.querySelectorAll('[data-slot="connector"]');
      expect(connectors).toHaveLength(2); // 3 steps = 2 connectors
    });

    it('should style completed connectors with teal', () => {
      const { container } = render(<Stepper steps={mockSteps} currentStep={2} />);

      const connectors = container.querySelectorAll('[data-slot="connector"]');
      expect(connectors[0]?.className).toMatch(/bg-teal-600/);
      expect(connectors[1]?.className).toMatch(/bg-teal-600/);
    });

    it('should not render connector after last step', () => {
      const { container } = render(<Stepper steps={mockSteps} currentStep={0} />);

      const items = container.querySelectorAll('[role="listitem"]');
      const lastItem = items[items.length - 1];
      const connector = lastItem?.querySelector('[data-slot="connector"]');
      expect(connector).toBeNull();
    });
  });

  describe('Accessibility', () => {
    it('should have aria-current on active step', () => {
      const { container } = render(<Stepper steps={mockSteps} currentStep={1} />);

      const activeStep = container.querySelector('[aria-current="step"]');
      expect(activeStep).toBeInTheDocument();
    });

    it('should have proper step list semantics', () => {
      render(<Stepper steps={mockSteps} currentStep={0} />);

      const list = screen.getByRole('list');
      expect(list).toBeInTheDocument();

      const items = screen.getAllByRole('listitem');
      expect(items).toHaveLength(3);
    });

    it('should use custom ariaLabel when provided', () => {
      render(<Stepper steps={mockSteps} currentStep={0} ariaLabel="Checkout progress" />);

      const list = screen.getByRole('list');
      expect(list).toHaveAttribute('aria-label', 'Checkout progress');
    });

    it('should hide icons from screen readers', () => {
      const { container } = render(<Stepper steps={mockSteps} currentStep={1} />);

      const icon = container.querySelector('svg');
      expect(icon).toHaveAttribute('aria-hidden', 'true');
    });
  });

  describe('Custom className', () => {
    it('should merge custom className', () => {
      const { container } = render(
        <Stepper steps={mockSteps} currentStep={0} className="custom-class" />
      );

      const stepper = container.querySelector('[data-slot="stepper"]');
      expect(stepper).toHaveClass('custom-class');
    });
  });

  describe('Edge Cases', () => {
    it('should handle single step', () => {
      const { container } = render(<Stepper steps={[{ label: 'Only Step' }]} currentStep={0} />);

      expect(screen.getByText('Only Step')).toBeInTheDocument();
      const connectors = container.querySelectorAll('[data-slot="connector"]');
      expect(connectors).toHaveLength(0);
    });

    it('should handle all steps completed', () => {
      render(<Stepper steps={mockSteps} currentStep={3} />);

      const completedSteps = screen.getAllByTestId('step-completed');
      expect(completedSteps).toHaveLength(3);
    });

    it('should clamp currentStep when out of range', () => {
      const { container } = render(<Stepper steps={mockSteps} currentStep={10} />);

      const items = container.querySelectorAll('[role="listitem"]');
      const lastItem = items[items.length - 1];
      expect(lastItem).toHaveAttribute('aria-current', 'step');
    });

    it('should return null for empty steps array', () => {
      const { container } = render(<Stepper steps={[]} currentStep={0} />);

      expect(container.querySelector('[data-slot="stepper"]')).toBeNull();
    });
  });
});
```

**Step 2: Run test to verify it fails**

Run: `pnpm --filter klard-web test src/__tests__/components/ui/stepper.test.tsx --run`
Expected: FAIL with "Cannot find module '@/components/ui/stepper'"

---

### Task 2: Implement Web Stepper Component (GREEN)

**Files:**
- Create: `klard-web/src/components/ui/stepper.tsx`

**Step 1: Write minimal implementation to pass tests**

```tsx
'use client';

import * as React from 'react';
import { Check } from 'lucide-react';
import { cn } from '@/lib/utils';

export interface Step {
  label: string;
  description?: string;
  status?: 'completed' | 'current' | 'upcoming';
}

export interface StepperProps {
  steps: Step[];
  currentStep: number;
  orientation?: 'horizontal' | 'vertical';
  ariaLabel?: string;
  className?: string;
}

type StepState = 'completed' | 'current' | 'upcoming';

/**
 * Clamp value between min and max
 */
function clamp(value: number, min: number, max: number): number {
  return Math.min(Math.max(value, min), max);
}

/**
 * Derive step state based on index and currentStep
 * Respects explicit status prop if provided
 */
function getStepState(index: number, currentStep: number, explicitStatus?: StepState): StepState {
  if (explicitStatus) return explicitStatus;
  if (index < currentStep) return 'completed';
  if (index === currentStep) return 'current';
  return 'upcoming';
}

const circleStyles: Record<StepState, string> = {
  completed: 'bg-teal-600 dark:bg-teal-500 text-white',
  current: 'bg-teal-600 dark:bg-teal-500 text-white ring-4 ring-teal-100 dark:ring-teal-900',
  upcoming: 'bg-slate-200 dark:bg-slate-700 text-slate-500 dark:text-slate-400',
};

const labelStyles: Record<StepState, string> = {
  completed: 'text-slate-900 dark:text-slate-100',
  current: 'text-slate-900 dark:text-slate-100 font-medium',
  upcoming: 'text-slate-500 dark:text-slate-400',
};

function Stepper({
  steps,
  currentStep,
  orientation = 'horizontal',
  ariaLabel,
  className,
}: StepperProps) {
  // Return null for empty steps
  if (!steps || steps.length === 0) {
    if (process.env.NODE_ENV === 'development') {
      console.warn('[Stepper] No steps provided');
    }
    return null;
  }

  const safeCurrent = clamp(currentStep, 0, steps.length - 1);
  const isHorizontal = orientation === 'horizontal';

  return (
    <div
      data-slot="stepper"
      className={cn(
        'flex',
        isHorizontal ? 'flex-row items-center' : 'flex-col',
        className
      )}
    >
      <ol
        role="list"
        aria-label={ariaLabel ?? 'Progress'}
        className={cn(
          'flex',
          isHorizontal ? 'flex-row items-center w-full' : 'flex-col gap-4'
        )}
      >
        {steps.map((step, index) => {
          const state = getStepState(index, safeCurrent, step.status);
          const isLast = index === steps.length - 1;

          return (
            <li
              key={index}
              role="listitem"
              className={cn(
                'flex',
                isHorizontal ? 'items-center' : 'flex-col',
                isHorizontal && !isLast && 'flex-1'
              )}
              aria-current={state === 'current' ? 'step' : undefined}
            >
              <div className={cn('flex items-center gap-2', !isHorizontal && 'gap-3')}>
                {/* Step Circle */}
                <div
                  data-state={state}
                  data-testid={state === 'completed' ? 'step-completed' : undefined}
                  className={cn(
                    'flex h-8 w-8 shrink-0 items-center justify-center rounded-full text-sm font-medium transition-all duration-200',
                    circleStyles[state]
                  )}
                >
                  {state === 'completed' ? (
                    <Check className="h-4 w-4" aria-hidden="true" />
                  ) : (
                    <span>{index + 1}</span>
                  )}
                </div>

                {/* Step Label */}
                <div className="flex flex-col min-w-0">
                  <span className={cn('text-sm', labelStyles[state])}>
                    {step.label}
                  </span>
                  {step.description && (
                    <span className="text-xs text-slate-500 dark:text-slate-400">
                      {step.description}
                    </span>
                  )}
                </div>
              </div>

              {/* Horizontal Connector */}
              {!isLast && isHorizontal && (
                <div
                  data-slot="connector"
                  className={cn(
                    'mx-4 h-0.5 flex-1 rounded-full transition-colors',
                    index < safeCurrent
                      ? 'bg-teal-600 dark:bg-teal-500'
                      : 'bg-slate-200 dark:bg-slate-700'
                  )}
                  aria-hidden="true"
                />
              )}

              {/* Vertical Connector */}
              {!isLast && !isHorizontal && (
                <div
                  data-slot="connector"
                  className={cn(
                    'ml-4 mt-2 h-8 w-0.5 rounded-full transition-colors',
                    index < safeCurrent
                      ? 'bg-teal-600 dark:bg-teal-500'
                      : 'bg-slate-200 dark:bg-slate-700'
                  )}
                  aria-hidden="true"
                />
              )}
            </li>
          );
        })}
      </ol>
    </div>
  );
}

export { Stepper };
```

**Step 2: Run test to verify it passes**

Run: `pnpm --filter klard-web test src/__tests__/components/ui/stepper.test.tsx --run`
Expected: PASS

**Step 3: Commit**

```bash
git add klard-web/src/components/ui/stepper.tsx klard-web/src/__tests__/components/ui/stepper.test.tsx
git commit -m "feat(web): add stepper component with TDD"
```

---

### Task 3: Export Web Stepper from Index

**Files:**
- Modify: `klard-web/src/components/ui/index.ts`

**Step 1: Add export**

Add to the end of the file:
```typescript
export { Stepper, type StepperProps, type Step } from './stepper';
```

**Step 2: Run TypeScript check**

Run: `pnpm --filter klard-web exec tsc --noEmit`
Expected: No errors

---

### Task 4: Create Mobile Stepper Test File (RED)

**Files:**
- Create: `klard-mobile/src/__tests__/components/ui/Stepper.test.tsx`

**Step 1: Write the failing tests**

```tsx
/**
 * Tests for Stepper Component (Mobile)
 *
 * TDD: Write failing tests first, then implement to pass.
 */

import React from 'react';
import { render, screen } from '@testing-library/react-native';
import { Stepper } from '@/components/ui/Stepper';

// Mock hooks
jest.mock('@/hooks', () => ({
  useThemeColors: () => ({
    primary: '#0D7C7A',
    muted: '#E2E8F0',
    textPrimary: '#0F172A',
    textSecondary: '#64748B',
    background: '#FFFFFF',
  }),
}));

const mockSteps = [
  { label: 'Step 1', description: 'First step' },
  { label: 'Step 2', description: 'Second step' },
  { label: 'Step 3', description: 'Third step' },
];

describe('Stepper', () => {
  describe('Rendering', () => {
    it('should render stepper container', () => {
      render(<Stepper steps={mockSteps} currentStep={0} />);

      expect(screen.getByTestId('stepper-container')).toBeTruthy();
    });

    it('should render all step labels', () => {
      render(<Stepper steps={mockSteps} currentStep={0} />);

      expect(screen.getByText('Step 1')).toBeTruthy();
      expect(screen.getByText('Step 2')).toBeTruthy();
      expect(screen.getByText('Step 3')).toBeTruthy();
    });

    it('should render step descriptions when provided', () => {
      render(<Stepper steps={mockSteps} currentStep={0} />);

      expect(screen.getByText('First step')).toBeTruthy();
    });

    it('should return null for empty steps', () => {
      const { queryByTestId } = render(<Stepper steps={[]} currentStep={0} />);

      expect(queryByTestId('stepper-container')).toBeNull();
    });
  });

  describe('Step States', () => {
    it('should mark completed steps', () => {
      render(<Stepper steps={mockSteps} currentStep={2} />);

      const completedSteps = screen.getAllByTestId('step-completed');
      expect(completedSteps).toHaveLength(2);
    });

    it('should mark active step', () => {
      render(<Stepper steps={mockSteps} currentStep={1} />);

      expect(screen.getByTestId('step-active')).toBeTruthy();
    });

    it('should show step numbers for pending steps', () => {
      render(<Stepper steps={mockSteps} currentStep={0} />);

      expect(screen.getByText('2')).toBeTruthy();
      expect(screen.getByText('3')).toBeTruthy();
    });

    it('should respect explicit status prop', () => {
      const stepsWithStatus = [
        { label: 'Step 1', status: 'upcoming' as const },
        { label: 'Step 2' },
        { label: 'Step 3' },
      ];
      render(<Stepper steps={stepsWithStatus} currentStep={2} />);

      expect(screen.getByTestId('step-pending')).toHaveTextContent('1');
    });
  });

  describe('Orientations', () => {
    it('should render horizontal by default', () => {
      render(<Stepper steps={mockSteps} currentStep={0} />);

      const container = screen.getByTestId('stepper-container');
      expect(container.props.style).toMatchObject(
        expect.objectContaining({ flexDirection: 'row' })
      );
    });

    it('should render vertical when orientation is vertical', () => {
      render(<Stepper steps={mockSteps} currentStep={0} orientation="vertical" />);

      const container = screen.getByTestId('stepper-container');
      expect(container.props.style).toMatchObject(
        expect.objectContaining({ flexDirection: 'column' })
      );
    });
  });

  describe('Connectors', () => {
    it('should render connectors between steps', () => {
      render(<Stepper steps={mockSteps} currentStep={0} />);

      const connectors = screen.getAllByTestId('step-connector');
      expect(connectors).toHaveLength(2);
    });

    it('should not render connectors for single step', () => {
      render(<Stepper steps={[{ label: 'Only Step' }]} currentStep={0} />);

      expect(screen.queryAllByTestId('step-connector')).toHaveLength(0);
    });
  });

  describe('Accessibility', () => {
    it('should have progressbar role on container', () => {
      render(<Stepper steps={mockSteps} currentStep={1} />);

      const container = screen.getByTestId('stepper-container');
      expect(container.props.accessibilityRole).toBe('progressbar');
    });

    it('should have correct accessibility value', () => {
      render(<Stepper steps={mockSteps} currentStep={1} />);

      const container = screen.getByTestId('stepper-container');
      expect(container.props.accessibilityValue).toEqual({
        now: 2,
        min: 1,
        max: 3,
        text: 'Step 2 of 3',
      });
    });

    it('should have selected state on current step', () => {
      render(<Stepper steps={mockSteps} currentStep={1} />);

      const activeStep = screen.getByTestId('step-active');
      expect(activeStep.props.accessibilityState).toMatchObject({ selected: true });
    });
  });

  describe('Edge Cases', () => {
    it('should handle single step', () => {
      render(<Stepper steps={[{ label: 'Only Step' }]} currentStep={0} />);

      expect(screen.getByText('Only Step')).toBeTruthy();
      expect(screen.queryAllByTestId('step-connector')).toHaveLength(0);
    });

    it('should handle all steps completed', () => {
      render(<Stepper steps={mockSteps} currentStep={3} />);

      const completedSteps = screen.getAllByTestId('step-completed');
      expect(completedSteps).toHaveLength(3);
    });

    it('should clamp currentStep when out of range', () => {
      render(<Stepper steps={mockSteps} currentStep={10} />);

      // Last step should be active
      expect(screen.getByTestId('step-active')).toBeTruthy();
    });
  });
});
```

**Step 2: Run test to verify it fails**

Run: `pnpm --filter klard-mobile test src/__tests__/components/ui/Stepper.test.tsx --run`
Expected: FAIL with "Cannot find module '@/components/ui/Stepper'"

---

### Task 5: Create Mobile Stepper Styles

**Files:**
- Create: `klard-mobile/src/components/ui/Stepper/stepper.styles.ts`

**Step 1: Write styles with detailed documentation**

```typescript
import { StyleSheet } from 'react-native';

/**
 * Stepper component styles
 *
 * Design tokens:
 * - Circle size: 32px
 * - Icon size: 16px
 * - Gap: 8px (horizontal), 12px (vertical)
 * - Connector thickness: 2px
 */
export const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  containerVertical: {
    flexDirection: 'column',
    alignItems: 'flex-start',
  },
  stepWrapper: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  stepWrapperVertical: {
    flexDirection: 'column',
    alignItems: 'flex-start',
  },
  stepContent: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  stepContentVertical: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  circle: {
    width: 32,
    height: 32,
    borderRadius: 16,
    alignItems: 'center',
    justifyContent: 'center',
  },
  circleActive: {
    // Ring effect via shadow (iOS) and elevation (Android)
    shadowColor: '#0D7C7A',
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 4,
  },
  circleNumber: {
    fontSize: 14,
    fontWeight: '500',
  },
  labelContainer: {
    flexDirection: 'column',
    flexShrink: 1, // Allow wrapping
  },
  label: {
    fontSize: 14,
  },
  labelActive: {
    fontWeight: '500',
  },
  description: {
    fontSize: 12,
    marginTop: 2,
  },
  connectorHorizontal: {
    height: 2,
    flex: 1,
    marginHorizontal: 16,
    borderRadius: 999, // Fully rounded
  },
  connectorVertical: {
    width: 2,
    height: 32,
    marginLeft: 15, // Center under 32px circle
    marginVertical: 8,
    borderRadius: 999, // Fully rounded
  },
});
```

---

### Task 6: Implement Mobile Stepper Component (GREEN)

**Files:**
- Create: `klard-mobile/src/components/ui/Stepper/Stepper.tsx`

**Step 1: Write implementation to pass tests**

```tsx
import React, { useMemo } from 'react';
import { View, Text, type StyleProp, type ViewStyle } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useThemeColors } from '@/hooks';
import { styles } from './stepper.styles';

export interface Step {
  label: string;
  description?: string;
  status?: 'completed' | 'current' | 'upcoming';
}

export interface StepperProps {
  steps: Step[];
  currentStep: number;
  orientation?: 'horizontal' | 'vertical';
  accessibilityLabel?: string;
  style?: StyleProp<ViewStyle>;
}

type StepState = 'completed' | 'current' | 'upcoming';

/**
 * Clamp value between min and max
 */
function clamp(value: number, min: number, max: number): number {
  return Math.min(Math.max(value, min), max);
}

/**
 * Derive step state based on index and currentStep
 * Respects explicit status prop if provided
 */
function getStepState(index: number, currentStep: number, explicitStatus?: StepState): StepState {
  if (explicitStatus) return explicitStatus;
  if (index < currentStep) return 'completed';
  if (index === currentStep) return 'current';
  return 'upcoming';
}

/**
 * Build accessibility label for a step
 */
function buildStepAccessibilityLabel(
  index: number,
  totalSteps: number,
  label: string,
  description: string | undefined,
  state: StepState
): string {
  const position = `Step ${index + 1} of ${totalSteps}`;
  const statusText = state === 'completed' ? 'completed' : state === 'current' ? 'in progress' : 'not started';
  const desc = description ? `, ${description}` : '';
  return `${position}: ${label}${desc}, ${statusText}`;
}

export function Stepper({
  steps,
  currentStep,
  orientation = 'horizontal',
  accessibilityLabel,
  style,
}: StepperProps) {
  const colors = useThemeColors();

  // Return null for empty steps
  if (!steps || steps.length === 0) {
    if (__DEV__) {
      console.warn('[Stepper] No steps provided');
    }
    return null;
  }

  const safeCurrent = clamp(currentStep, 0, steps.length - 1);
  const isHorizontal = orientation === 'horizontal';

  const getCircleStyle = (state: StepState): ViewStyle => {
    const baseStyle: ViewStyle = {
      ...styles.circle,
      backgroundColor: state === 'upcoming' ? colors.muted : colors.primary,
    };

    if (state === 'current') {
      return { ...baseStyle, ...styles.circleActive };
    }

    return baseStyle;
  };

  const getCircleTextColor = (state: StepState): string => {
    return state === 'upcoming' ? colors.textSecondary : '#FFFFFF';
  };

  const getLabelColor = (state: StepState): string => {
    return state === 'upcoming' ? colors.textSecondary : colors.textPrimary;
  };

  const getConnectorColor = (index: number): string => {
    return index < safeCurrent ? colors.primary : colors.muted;
  };

  return (
    <View
      testID="stepper-container"
      accessibilityRole="progressbar"
      accessibilityLabel={accessibilityLabel}
      accessibilityValue={{
        now: safeCurrent + 1,
        min: 1,
        max: steps.length,
        text: `Step ${safeCurrent + 1} of ${steps.length}`,
      }}
      style={[
        isHorizontal ? styles.container : styles.containerVertical,
        style,
      ]}
    >
      {steps.map((step, index) => {
        const state = getStepState(index, safeCurrent, step.status);
        const isLast = index === steps.length - 1;
        const stepAccessibilityLabel = buildStepAccessibilityLabel(
          index,
          steps.length,
          step.label,
          step.description,
          state
        );

        return (
          <React.Fragment key={index}>
            <View
              style={[
                isHorizontal ? styles.stepWrapper : styles.stepWrapperVertical,
                isHorizontal && !isLast && { flex: 1 },
              ]}
            >
              <View
                accessibilityRole="text"
                accessibilityLabel={stepAccessibilityLabel}
                accessibilityState={{ selected: state === 'current' }}
                style={isHorizontal ? styles.stepContent : styles.stepContentVertical}
              >
                {/* Step Circle */}
                <View
                  testID={
                    state === 'completed'
                      ? 'step-completed'
                      : state === 'current'
                      ? 'step-active'
                      : 'step-pending'
                  }
                  style={getCircleStyle(state)}
                >
                  {state === 'completed' ? (
                    <Ionicons
                      name="checkmark"
                      size={16}
                      color="#FFFFFF"
                    />
                  ) : (
                    <Text
                      style={[
                        styles.circleNumber,
                        { color: getCircleTextColor(state) },
                      ]}
                    >
                      {index + 1}
                    </Text>
                  )}
                </View>

                {/* Step Label */}
                <View style={styles.labelContainer}>
                  <Text
                    style={[
                      styles.label,
                      state === 'current' && styles.labelActive,
                      { color: getLabelColor(state) },
                    ]}
                  >
                    {step.label}
                  </Text>
                  {step.description && (
                    <Text
                      style={[
                        styles.description,
                        { color: colors.textSecondary },
                      ]}
                    >
                      {step.description}
                    </Text>
                  )}
                </View>
              </View>

              {/* Horizontal Connector (inside step wrapper for flex) */}
              {!isLast && isHorizontal && (
                <View
                  testID="step-connector"
                  style={[
                    styles.connectorHorizontal,
                    { backgroundColor: getConnectorColor(index) },
                  ]}
                />
              )}
            </View>

            {/* Vertical Connector */}
            {!isLast && !isHorizontal && (
              <View
                testID="step-connector"
                style={[
                  styles.connectorVertical,
                  { backgroundColor: getConnectorColor(index) },
                ]}
              />
            )}
          </React.Fragment>
        );
      })}
    </View>
  );
}
```

**Step 2: Run test to verify it passes**

Run: `pnpm --filter klard-mobile test src/__tests__/components/ui/Stepper.test.tsx --run`
Expected: PASS

**Step 3: Commit**

```bash
git add klard-mobile/src/components/ui/Stepper/ klard-mobile/src/__tests__/components/ui/Stepper.test.tsx
git commit -m "feat(mobile): add stepper component with TDD"
```

---

### Task 7: Create Mobile Stepper Index Export

**Files:**
- Create: `klard-mobile/src/components/ui/Stepper/index.ts`

**Step 1: Write export**

```typescript
export { Stepper, type StepperProps, type Step } from './Stepper';
```

---

### Task 8: Export Mobile Stepper from UI Index

**Files:**
- Modify: `klard-mobile/src/components/ui/index.ts`

**Step 1: Add export**

Add to the end of the file:
```typescript
export { Stepper, type StepperProps, type Step } from './Stepper';
```

**Step 2: Run TypeScript check**

Run: `pnpm --filter klard-mobile exec tsc --noEmit`
Expected: No errors

---

### Task 9: Run Full Test Suite and TypeScript Check

**Step 1: Run all web tests**

Run: `pnpm --filter klard-web test --run`
Expected: All tests pass

**Step 2: Run all mobile tests**

Run: `pnpm --filter klard-mobile test --run`
Expected: All tests pass

**Step 3: Run TypeScript check for both**

Run: `pnpm --filter klard-web exec tsc --noEmit && pnpm --filter klard-mobile exec tsc --noEmit`
Expected: No errors

---

### Task 10: Mark Spec as DONE

**Files:**
- Modify: `docs/screens/batch/Klard_Component_Specifications.md`

**Step 1: Update marker**

Replace `<!-- IN-PROGRESS:3.7-stepper-progress-indicator -->` with `<!-- DONE:3.7-stepper-progress-indicator -->`

**Step 2: Final commit**

```bash
git add docs/screens/batch/Klard_Component_Specifications.md
git commit -m "docs: mark stepper component as done"
```

---

## Verification Checklist

Before marking complete, verify:

### Functionality
- [ ] Web component renders without errors
- [ ] Mobile component renders without errors
- [ ] All props implemented and typed correctly
- [ ] All visual states functional (completed, current, upcoming)
- [ ] Both orientations work (horizontal, vertical)
- [ ] Explicit status prop overrides derived state
- [ ] Empty steps array returns null gracefully
- [ ] currentStep clamping works for out-of-range values

### Accessibility
- [ ] Web: role="list", aria-label, aria-current on active step
- [ ] Mobile: accessibilityRole="progressbar", accessibilityValue, accessibilityState
- [ ] Icons have aria-hidden (web) or are included in accessibility labels (mobile)
- [ ] Custom ariaLabel/accessibilityLabel props work
- [ ] Step position announced in accessibility labels (mobile)

### Visual & Styling
- [ ] Circles are 32px with correct colors per state
- [ ] Completed steps show checkmark icon
- [ ] Active step has ring effect (web) or shadow (mobile)
- [ ] Connectors render between steps with correct colors
- [ ] No connector after last step
- [ ] Labels and descriptions render with correct colors
- [ ] Dark mode support works (web)

### Testing & Type Safety
- [ ] TypeScript passes with no errors
- [ ] All web tests pass
- [ ] All mobile tests pass
- [ ] Test coverage includes edge cases (empty, single step, all completed)
- [ ] Tests verify accessibility attributes

### Exports & Documentation
- [ ] Exported from components/ui/index.ts (both platforms)
- [ ] Type exports included (Step, StepperProps)
- [ ] Spec marker updated to DONE

### Quality Gates (from old plan)
- [ ] Do not skip failing test confirmation (RED phase verified)
- [ ] Do not merge without spec marker DONE
- [ ] No `any` types in implementation
- [ ] Data attributes present on web (`data-slot`, `data-state`)
- [ ] Safe area considerations applied (mobile)

---

## Extended Edge Cases & Manual QA

### Edge Cases to Validate
1. **Single-step flow**: No connectors render; single step shows as active
2. **Two steps**: Single connector between them
3. **Long labels**: Text wraps on multiple lines without breaking layout
4. **Descriptions on some steps only**: Layout remains consistent
5. **Mixed explicit statuses**: Override logic works (e.g., step 0 status='upcoming' even when currentStep=2)
6. **Orientation vertical on web**: Long labels don't cause overflow
7. **RTL layout**: Visual sanity check (manual, not unit test)
8. **Dark theme**: All colors readable and accessible (manual check)

### Manual QA Scenarios (Web)
1. Render with 4 steps, currentStep=2; check visuals match design
2. Toggle orientation prop to vertical; verify layout adapts
3. Set custom ariaLabel; inspect DOM to confirm
4. Provide explicit statuses; verify they override derived
5. Resize window to small width; ensure horizontal layout stays intact or allows wrapping

### Manual QA Scenarios (Mobile)
1. Render vertical Stepper; verify icons and colors match design
2. Switch to horizontal orientation; verify connectors align properly
3. Simulate device with notch (safe area insets); verify padding applied
4. Set currentStep beyond length; verify clamping to last step
5. Add descriptions to some steps; check text wrapping and color

---

## Implementation Micro-Steps

### Web Implementation Details (2-5 min each)
1. Create file with `'use client'` directive
2. Import dependencies: `cn`, `Check` icon, React
3. Define types: `Step`, `StepperProps`, `StepState`
4. Define helper `clamp(value, min, max)`
5. Define `getStepState(index, currentStep, explicitStatus)`
6. Define `circleStyles` record with variants
7. Define `labelStyles` record with variants
8. Normalize steps with safeCurrent clamp
9. Render container `<div>` with `data-slot="stepper"`
10. Render `<ol role="list" aria-label={...}>`
11. Map steps to `<li role="listitem">` with aria-current logic
12. Render circle div with state classes and icon/number
13. Render label/description with semantic colors
14. Render horizontal connector with conditional classes
15. Render vertical connector with conditional classes
16. Export component and types

### Mobile Implementation Details (2-5 min each)
1. Import RN primitives, Ionicons, useThemeColors
2. Define types: `Step`, `StepperProps`, `StepState`
3. Define helper `clamp(value, min, max)`
4. Define `getStepState(index, currentStep, explicitStatus)`
5. Define `buildStepAccessibilityLabel(...)` helper
6. Compute safeCurrent with useMemo for normalized steps
7. Define `getCircleStyle(state)` returning ViewStyle
8. Define `getCircleTextColor(state)`, `getLabelColor(state)`, `getConnectorColor(index)`
9. Render container View with testID, accessibilityRole, accessibilityValue
10. Map steps to Fragment with step wrapper View
11. Render step content View with accessibility props
12. Render circle View with state-based styles
13. Render Ionicons checkmark for completed, Text for number
14. Render label container with Text and optional description
15. Render horizontal connector conditionally
16. Render vertical connector conditionally after step wrapper
17. Export component and types

---

## Commands Reference

- **Web test (scoped)**: `pnpm --filter klard-web test src/__tests__/components/ui/stepper.test.tsx --run`
- **Mobile test (scoped)**: `pnpm --filter klard-mobile test src/__tests__/components/ui/Stepper.test.tsx --run`
- **Web TypeScript check**: `pnpm --filter klard-web exec tsc --noEmit`
- **Mobile TypeScript check**: `pnpm --filter klard-mobile exec tsc --noEmit`
- **All web tests**: `pnpm --filter klard-web test --run`
- **All mobile tests**: `pnpm --filter klard-mobile test --run`

---

## Risk Mitigations

1. **RTL/layout**: Avoid left/right-specific padding; use symmetric margins (`mx-` classes on web)
2. **Icon rendering in tests**: Use testIDs (`data-testid` on web, `testID` on mobile) for clarity
3. **Performance**: Minimal state; pure rendering; avoid useEffect; use useMemo for derived data on mobile
4. **Accessibility**: Ensure `aria-current` only on current step; `role` semantics correct; icons aria-hidden or included in labels
5. **Color contrast**: Verify muted text meets WCAG AA standards (4.5:1 ratio)
6. **Connector alignment**: Use flexbox alignment; test vertical connectors center under circles

---

## Future Enhancements (Out of Scope)

1. **Clickable steps**: Add `onStepPress` callback for navigation
2. **Error state**: Add red color variant for failed steps
3. **Animated progress bars**: Smooth transitions between steps
4. **Theming via context**: Allow custom color schemes
5. **Responsive collapse**: Automatically switch to vertical on small screens
6. **Step validation**: Show validation status per step

---

## Parallel Sub-Agent Strategy

Tasks that can run in parallel:
- **Task 1 + Task 4**: Web and Mobile test files (independent)
- **Task 5 + Task 2**: Mobile styles + Web implementation (after tests exist)
- **Task 3 + Task 7-8**: Web export + Mobile exports (after implementations)

Sequential dependencies:
- Task 1 must complete before Task 2 (RED before GREEN)
- Task 4 must complete before Task 5, 6 (RED before GREEN)
- Task 6 must complete before Task 7, 8 (implementation before exports)
- Task 9 must run after all implementations (verification gate)
- Task 10 runs last (final marker update)

---

## Summary

This merged plan combines:
- **Comprehensive test coverage** from new plan (complete test code)
- **Detailed accessibility semantics** from old plan (list/listitem roles, custom labels)
- **SOLID analysis** from both plans (table + prose)
- **Color token documentation** from old plan (hex values + design tokens)
- **Extended edge cases** from old plan (manual QA scenarios)
- **Micro-step guidance** from old plan (2-5 min task breakdown)
- **Quality gates** from old plan (verification before completion)

The result is a production-ready implementation plan with strict TDD discipline, comprehensive accessibility, and thorough verification steps.