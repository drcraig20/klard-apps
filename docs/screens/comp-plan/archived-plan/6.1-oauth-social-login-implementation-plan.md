# 6.1 OAuth / Social Login Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Deliver production-ready social authentication buttons (Google + Apple) for web and mobile with comprehensive TDD coverage, proper loading/disabled/error handling, native platform integrations, and haptic feedback using the existing auth client.

**Architecture:** Two-layer structure: a primitive `SocialButton` (web) renders provider-specific UI with full state management, while a composed `SocialButtons` container manages async login state for multiple providers, dispatches `signIn.social`, and surfaces errors via `onError`. Mobile wraps native Apple button when available (iOS) and uses auth client flows via Expo integrations with haptic feedback.

**Tech Stack:** Next.js 16 + React 19 + shadcn/ui + better-auth client + Vitest/RTL (web); Expo 54 + React Native + expo-apple-authentication + expo-web-browser + expo-haptics + better-auth/expo + Jest/RNTL (mobile).

---

## Plan Content

- **Component:** OAuth / Social Login (Google + Apple)
- **Target platforms:** Web and Mobile
- **Props interface (container):** `disabled?: boolean; onError?: (message: string) => void; onSuccess?: () => void` (web/mobile symmetry), internal provider config array.
- **Props interface (primitive - web only):** `provider: string; icon: React.ReactNode; onClick: () => void; isLoading?: boolean; disabled?: boolean; className?: string`
- **Visual states:** default, hover/focus (web), pressed/active, disabled, loading (per-provider with spinner), error surfaced via `onError` callback (caller renders message).
- **Size/spacing:** 48px height (web), 12px radius, gap-8 icon/text, full-width container with 12-16px gaps; mobile uses StyleSheet with 48px height, radius 12, gap 8, flex-1 for equal width distribution.
- **Color tokens:** Web uses shadcn variants + Klard tokens (`text-foreground`, `border-border`, muted hover, primary focus outline); Mobile uses `useThemeColors` for `foreground`, `border`, `primary`.
- **Accessibility:** `role="button"`/`accessibilityRole="button"`, `aria-label`/`accessibilityLabel` like "Continue with Google" or "Sign in with Apple", keyboard focus ring on web, Apple button only when Platform.OS === 'ios' and available, type="button" to prevent form submission.
- **Dependencies:** Web: `@/lib/auth-client` (`signIn`), `@/components/ui/social-button`, `@/components/ui/icons`; Mobile: `@/lib/auth-client` (`signIn`), `expo-apple-authentication`, `expo-web-browser`, `expo-haptics`, `expo-linking` (redirect handling if needed), `useThemeColors`.
- **SOLID compliance:**

| Component | SRP | OCP | LSP | ISP | DIP |
|-----------|-----|-----|-----|-----|-----|
| SocialButton (web) | Renders single social button with state | Extensible via props/styles | Handles all button states, remains substitutable | Minimal prop interface | Depends on props + utils abstractions |
| SocialButtons (web) | Manages auth flow + loading gating for multiple providers | Add providers via data array | Composition, not inheritance | Narrow props (disabled/onError/onSuccess) | Depends on `signIn` abstraction, injects dependency |
| SocialButtons (mobile) | Manages auth flow + platform gating + haptics | Providers added via config, platform-specific rendering | Composition | Minimal props (disabled/onError/onSuccess) | Uses auth client + Expo APIs abstractions |

- **Parallel sub-agent strategy:** Tasks are independent (web primitive tests vs web container tests vs mobile tests/impl). Execute sequentially in this session (subagent tooling unavailable in Codex; I will perform each "subagent" task myself and review between tasks).
- **Test strategy (TDD first):**
  - Web Primitive (SocialButton): Rendering (provider name, icon, button element, type="button"), loading state (spinner, hide icon, disabled), disabled state (disabled, opacity, no onClick), click handling (calls onClick, prevents when disabled/loading), styling (outline, flex-1, custom className), edge cases (disabled+loading, empty provider).
  - Web Container (SocialButtons): Rendering (both providers, icons, flex container with gap), auth flow (signIn.social with correct provider), loading state (per-provider loading, disable all buttons, re-enable after), error handling (onError callback, re-enable after error), disabled state (disable all, prevent calls).
  - Mobile (SocialButtons): Rendering (Google, native Apple on iOS, custom Apple on Android), Google auth (signIn.social, haptic feedback), Apple auth (native signInAsync on iOS), loading state (ActivityIndicator, disable buttons), error handling (onError, handle cancellation gracefully), disabled state (prevent calls), haptic feedback.

---

## Bite-Sized Tasks

### Task 1: Web – Write failing tests for SocialButton primitive

**Files:**
- Create: `klard-web/src/__tests__/components/ui/social-button.test.tsx`

**Step 1: Write the failing test**
```tsx
/**
 * Tests for SocialButton Component
 *
 * These tests verify:
 * 1. Renders provider name and icon
 * 2. Loading state shows spinner
 * 3. Disabled state prevents interaction
 * 4. Click handler is called
 * 5. Accessibility attributes
 * 6. Edge cases (disabled+loading, empty provider)
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { SocialButton } from '@/components/ui/social-button';

describe('SocialButton', () => {
  const mockOnClick = vi.fn();
  const mockIcon = <span data-testid="mock-icon">Icon</span>;

  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('Rendering', () => {
    it('should render provider name', () => {
      render(
        <SocialButton provider="Google" icon={mockIcon} onClick={mockOnClick} />
      );

      expect(screen.getByText('Google')).toBeTruthy();
    });

    it('should render icon', () => {
      render(
        <SocialButton provider="Google" icon={mockIcon} onClick={mockOnClick} />
      );

      expect(screen.getByTestId('mock-icon')).toBeTruthy();
    });

    it('should be a button element', () => {
      render(
        <SocialButton provider="Google" icon={mockIcon} onClick={mockOnClick} />
      );

      const button = screen.getByRole('button');
      expect(button.tagName).toBe('BUTTON');
    });

    it('should have type="button" to prevent form submission', () => {
      render(
        <SocialButton provider="Google" icon={mockIcon} onClick={mockOnClick} />
      );

      const button = screen.getByRole('button');
      expect(button.getAttribute('type')).toBe('button');
    });

    it('should have data-slot for traceability', () => {
      render(
        <SocialButton provider="Google" icon={mockIcon} onClick={mockOnClick} />
      );

      expect(screen.getByRole('button')).toHaveAttribute('data-slot', 'social-button');
    });
  });

  describe('Loading State', () => {
    it('should show spinner when loading', () => {
      render(
        <SocialButton
          provider="Google"
          icon={mockIcon}
          onClick={mockOnClick}
          isLoading
        />
      );

      // LoadingSpinner renders with specific class or testid
      const button = screen.getByRole('button');
      expect(button.querySelector('[class*="animate-spin"]') ||
             button.querySelector('[data-testid="spinner"]')).toBeTruthy();
    });

    it('should hide icon when loading', () => {
      render(
        <SocialButton
          provider="Google"
          icon={mockIcon}
          onClick={mockOnClick}
          isLoading
        />
      );

      expect(screen.queryByTestId('mock-icon')).toBeNull();
    });

    it('should be disabled when loading', () => {
      render(
        <SocialButton
          provider="Google"
          icon={mockIcon}
          onClick={mockOnClick}
          isLoading
        />
      );

      expect(screen.getByRole('button')).toBeDisabled();
    });
  });

  describe('Disabled State', () => {
    it('should be disabled when disabled prop is true', () => {
      render(
        <SocialButton
          provider="Google"
          icon={mockIcon}
          onClick={mockOnClick}
          disabled
        />
      );

      expect(screen.getByRole('button')).toBeDisabled();
    });

    it('should have reduced opacity when disabled', () => {
      render(
        <SocialButton
          provider="Google"
          icon={mockIcon}
          onClick={mockOnClick}
          disabled
        />
      );

      const button = screen.getByRole('button');
      expect(button.className).toContain('disabled:opacity-50');
    });

    it('should not call onClick when disabled', () => {
      render(
        <SocialButton
          provider="Google"
          icon={mockIcon}
          onClick={mockOnClick}
          disabled
        />
      );

      fireEvent.click(screen.getByRole('button'));
      expect(mockOnClick).not.toHaveBeenCalled();
    });
  });

  describe('Click Handling', () => {
    it('should call onClick when clicked', () => {
      render(
        <SocialButton provider="Google" icon={mockIcon} onClick={mockOnClick} />
      );

      fireEvent.click(screen.getByRole('button'));
      expect(mockOnClick).toHaveBeenCalledTimes(1);
    });

    it('should not call onClick when loading', () => {
      render(
        <SocialButton
          provider="Google"
          icon={mockIcon}
          onClick={mockOnClick}
          isLoading
        />
      );

      fireEvent.click(screen.getByRole('button'));
      expect(mockOnClick).not.toHaveBeenCalled();
    });
  });

  describe('Styling', () => {
    it('should apply outline button styling', () => {
      render(
        <SocialButton provider="Google" icon={mockIcon} onClick={mockOnClick} />
      );

      const button = screen.getByRole('button');
      expect(button.className).toContain('border');
    });

    it('should apply flex-1 for equal width distribution', () => {
      render(
        <SocialButton provider="Google" icon={mockIcon} onClick={mockOnClick} />
      );

      const button = screen.getByRole('button');
      expect(button.className).toContain('flex-1');
    });

    it('should merge custom className', () => {
      render(
        <SocialButton
          provider="Google"
          icon={mockIcon}
          onClick={mockOnClick}
          className="custom-class"
        />
      );

      const button = screen.getByRole('button');
      expect(button.className).toContain('custom-class');
    });
  });

  describe('Edge Cases', () => {
    it('should handle both disabled and loading simultaneously', () => {
      render(
        <SocialButton
          provider="Google"
          icon={mockIcon}
          onClick={mockOnClick}
          disabled
          isLoading
        />
      );

      const button = screen.getByRole('button');
      expect(button).toBeDisabled();
    });

    it('should render with empty provider name', () => {
      render(
        <SocialButton provider="" icon={mockIcon} onClick={mockOnClick} />
      );

      expect(screen.getByRole('button')).toBeTruthy();
    });
  });
});
```

**Step 2: Run test to verify it fails**
- Run: `pnpm --filter klard-web test src/__tests__/components/ui/social-button.test.tsx --run`
- Expected: Tests should pass since component already exists, or FAIL if missing behaviors.

**Step 3: Verify/update implementation**
- Verify existing `klard-web/src/components/ui/social-button.tsx` passes all tests.
- If any fail, update to match expected behavior:
  - Add `data-slot="social-button"` attribute
  - Add `type="button"` attribute
  - Ensure spinner has `data-testid="spinner"` for detection
  - Ensure `disabled:opacity-50` styling
  - Guard click when disabled/loading

**Step 4: Run test to verify it passes**
- Run: `pnpm --filter klard-web test src/__tests__/components/ui/social-button.test.tsx --run`
- Expected: PASS.

**Step 5: Commit**
- `git add klard-web/src/__tests__/components/ui/social-button.test.tsx klard-web/src/components/ui/social-button.tsx`
- `git commit -m "test(web): add SocialButton primitive tests and data-slot"`

---

### Task 2: Web – Write failing tests for SocialButtons container

**Files:**
- Create: `klard-web/src/__tests__/components/auth/social-buttons.test.tsx`

**Step 1: Write the failing test**
```tsx
/**
 * Tests for SocialButtons Component
 *
 * These tests verify:
 * 1. Renders all configured providers
 * 2. Handles loading state per provider
 * 3. Calls signIn.social with correct provider
 * 4. Error handling and onError callback
 * 5. Success callback invocation
 * 6. Disabled state propagation
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { SocialButtons } from '@/components/auth/social-buttons';

// Mock the auth client
vi.mock('@/lib/auth-client', () => ({
  signIn: {
    social: vi.fn(),
  },
}));

// Mock the icons
vi.mock('@/components/ui/icons', () => ({
  GoogleIcon: () => <span data-testid="google-icon">G</span>,
  AppleIcon: () => <span data-testid="apple-icon">A</span>,
}));

import { signIn } from '@/lib/auth-client';

describe('SocialButtons', () => {
  const mockOnError = vi.fn();
  const mockOnSuccess = vi.fn();

  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('Rendering', () => {
    it('should render Google provider button', () => {
      render(<SocialButtons />);

      expect(screen.getByText('Google')).toBeTruthy();
    });

    it('should render Apple provider button', () => {
      render(<SocialButtons />);

      expect(screen.getByText('Apple')).toBeTruthy();
    });

    it('should render provider icons', () => {
      render(<SocialButtons />);

      expect(screen.getByTestId('google-icon')).toBeTruthy();
      expect(screen.getByTestId('apple-icon')).toBeTruthy();
    });

    it('should render buttons in a flex container with gap', () => {
      const { container } = render(<SocialButtons />);

      const wrapper = container.firstChild as HTMLElement;
      expect(wrapper.className).toContain('flex');
      expect(wrapper.className).toContain('gap-4');
    });
  });

  describe('Authentication Flow', () => {
    it('should call signIn.social with google provider when Google clicked', async () => {
      (signIn.social as ReturnType<typeof vi.fn>).mockResolvedValueOnce({});

      render(<SocialButtons />);

      fireEvent.click(screen.getByText('Google'));

      await waitFor(() => {
        expect(signIn.social).toHaveBeenCalledWith({ provider: 'google' });
      });
    });

    it('should call signIn.social with apple provider when Apple clicked', async () => {
      (signIn.social as ReturnType<typeof vi.fn>).mockResolvedValueOnce({});

      render(<SocialButtons />);

      fireEvent.click(screen.getByText('Apple'));

      await waitFor(() => {
        expect(signIn.social).toHaveBeenCalledWith({ provider: 'apple' });
      });
    });

    it('should call onSuccess when authentication succeeds', async () => {
      (signIn.social as ReturnType<typeof vi.fn>).mockResolvedValueOnce({});

      render(<SocialButtons onSuccess={mockOnSuccess} />);

      fireEvent.click(screen.getByText('Google'));

      await waitFor(() => {
        expect(mockOnSuccess).toHaveBeenCalledTimes(1);
      });
    });
  });

  describe('Loading State', () => {
    it('should show loading on clicked provider only', async () => {
      let resolvePromise: () => void;
      const promise = new Promise<void>((resolve) => {
        resolvePromise = resolve;
      });
      (signIn.social as ReturnType<typeof vi.fn>).mockReturnValueOnce(promise);

      render(<SocialButtons />);

      fireEvent.click(screen.getByText('Google'));

      // Google button should be loading
      await waitFor(() => {
        const buttons = screen.getAllByRole('button');
        expect(buttons[0]).toBeDisabled(); // Google
      });

      // Resolve to clean up
      resolvePromise!();
    });

    it('should disable all buttons while one is loading', async () => {
      let resolvePromise: () => void;
      const promise = new Promise<void>((resolve) => {
        resolvePromise = resolve;
      });
      (signIn.social as ReturnType<typeof vi.fn>).mockReturnValueOnce(promise);

      render(<SocialButtons />);

      fireEvent.click(screen.getByText('Google'));

      await waitFor(() => {
        const buttons = screen.getAllByRole('button');
        buttons.forEach((button) => {
          expect(button).toBeDisabled();
        });
      });

      resolvePromise!();
    });

    it('should re-enable buttons after authentication completes', async () => {
      (signIn.social as ReturnType<typeof vi.fn>).mockResolvedValueOnce({});

      render(<SocialButtons />);

      fireEvent.click(screen.getByText('Google'));

      await waitFor(() => {
        const buttons = screen.getAllByRole('button');
        buttons.forEach((button) => {
          expect(button).not.toBeDisabled();
        });
      });
    });
  });

  describe('Error Handling', () => {
    it('should call onError when authentication fails', async () => {
      (signIn.social as ReturnType<typeof vi.fn>).mockRejectedValueOnce(
        new Error('Auth failed')
      );

      render(<SocialButtons onError={mockOnError} />);

      fireEvent.click(screen.getByText('Google'));

      await waitFor(() => {
        expect(mockOnError).toHaveBeenCalledWith(
          'Failed to sign in with google. Please try again.'
        );
      });
    });

    it('should re-enable buttons after error', async () => {
      (signIn.social as ReturnType<typeof vi.fn>).mockRejectedValueOnce(
        new Error('Auth failed')
      );

      render(<SocialButtons onError={mockOnError} />);

      fireEvent.click(screen.getByText('Google'));

      await waitFor(() => {
        const buttons = screen.getAllByRole('button');
        buttons.forEach((button) => {
          expect(button).not.toBeDisabled();
        });
      });
    });
  });

  describe('Disabled State', () => {
    it('should disable all buttons when disabled prop is true', () => {
      render(<SocialButtons disabled />);

      const buttons = screen.getAllByRole('button');
      buttons.forEach((button) => {
        expect(button).toBeDisabled();
      });
    });

    it('should not call signIn.social when disabled', () => {
      render(<SocialButtons disabled />);

      fireEvent.click(screen.getByText('Google'));

      expect(signIn.social).not.toHaveBeenCalled();
    });
  });
});
```

**Step 2: Run test to verify it fails**
- Run: `pnpm --filter klard-web test src/__tests__/components/auth/social-buttons.test.tsx --run`
- Expected: Tests should pass since component already exists, or FAIL if missing behaviors.

**Step 3: Verify/update implementation**
- Update `klard-web/src/components/auth/social-buttons.tsx` to:
  - Accept optional `onSuccess` callback
  - Invoke `onSuccess()` on successful authentication
  - Ensure per-provider loading state with `loadingProvider` state
  - Disable both buttons when any provider is loading or when `disabled` prop is true
  - Surface errors via `onError` with provider name; reset loading in finally
  - Ensure flex container with gap-4 styling

**Step 4: Run test to verify it passes**
- Run: `pnpm --filter klard-web test src/__tests__/components/auth/social-buttons.test.tsx --run`
- Expected: PASS.

**Step 5: Commit**
- `git add klard-web/src/components/auth/social-buttons.tsx klard-web/src/__tests__/components/auth/social-buttons.test.tsx`
- `git commit -m "feat(web): add social login container tests and onSuccess callback"`

---

### Task 3: Mobile – Write failing tests and implement native Apple Sign In

**Files:**
- Create: `klard-mobile/src/__tests__/components/auth/SocialButtons.test.tsx`
- Update: `klard-mobile/src/components/auth/social-buttons.tsx`

**Step 1: Write the failing test**
```tsx
/**
 * Tests for SocialButtons Component (Mobile)
 *
 * These tests verify:
 * 1. Renders Google and Apple buttons
 * 2. Uses native Apple button on iOS
 * 3. Loading states
 * 4. Error handling (including cancellation)
 * 5. Haptic feedback
 * 6. Disabled state
 */

import React from 'react';
import { render, fireEvent, waitFor } from '@testing-library/react-native';
import { Platform } from 'react-native';
import * as Haptics from 'expo-haptics';
import { SocialButtons } from '@/components/auth/social-buttons';

// Mock expo-haptics
jest.mock('expo-haptics', () => ({
  impactAsync: jest.fn(),
  ImpactFeedbackStyle: {
    Light: 'light',
  },
}));

// Mock the auth client
jest.mock('@/lib/auth-client', () => ({
  signIn: {
    social: jest.fn(),
  },
}));

// Mock expo-apple-authentication
jest.mock('expo-apple-authentication', () => ({
  signInAsync: jest.fn(),
  AppleAuthenticationButton: ({ onPress, style }: any) => {
    const { TouchableOpacity, Text } = require('react-native');
    return (
      <TouchableOpacity
        testID="apple-native-button"
        onPress={onPress}
        style={style}
        accessibilityRole="button"
      >
        <Text>Sign in with Apple</Text>
      </TouchableOpacity>
    );
  },
  AppleAuthenticationButtonType: {
    SIGN_IN: 0,
  },
  AppleAuthenticationButtonStyle: {
    BLACK: 0,
    WHITE: 1,
  },
  AppleAuthenticationScope: {
    FULL_NAME: 0,
    EMAIL: 1,
  },
  isAvailableAsync: jest.fn().mockResolvedValue(true),
}));

// Mock useThemeColors hook
jest.mock('@/hooks', () => ({
  useThemeColors: () => ({
    foreground: '#000000',
    border: '#E2E8F0',
    primary: '#0D7C7A',
  }),
}));

import { signIn } from '@/lib/auth-client';
import * as AppleAuthentication from 'expo-apple-authentication';

describe('SocialButtons (Mobile)', () => {
  const mockOnError = jest.fn();
  const mockOnSuccess = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
    Platform.OS = 'ios';
  });

  describe('Rendering', () => {
    it('should render Google button', () => {
      const { getByText } = render(<SocialButtons />);

      expect(getByText('Google')).toBeTruthy();
    });

    it('should render Apple button on iOS', () => {
      Platform.OS = 'ios';
      const { getByTestId } = render(<SocialButtons />);

      expect(getByTestId('apple-native-button')).toBeTruthy();
    });

    it('should render custom Apple button on Android', () => {
      Platform.OS = 'android';
      const { getByText } = render(<SocialButtons />);

      expect(getByText('Apple')).toBeTruthy();
    });
  });

  describe('Google Authentication', () => {
    it('should call signIn.social with google provider', async () => {
      (signIn.social as jest.Mock).mockResolvedValueOnce({});

      const { getByText } = render(<SocialButtons />);

      fireEvent.press(getByText('Google'));

      await waitFor(() => {
        expect(signIn.social).toHaveBeenCalledWith({ provider: 'google' });
      });
    });

    it('should trigger haptic feedback on press', async () => {
      (signIn.social as jest.Mock).mockResolvedValueOnce({});

      const { getByText } = render(<SocialButtons />);

      fireEvent.press(getByText('Google'));

      await waitFor(() => {
        expect(Haptics.impactAsync).toHaveBeenCalledWith(
          Haptics.ImpactFeedbackStyle.Light
        );
      });
    });

    it('should call onSuccess when Google auth succeeds', async () => {
      (signIn.social as jest.Mock).mockResolvedValueOnce({});

      const { getByText } = render(<SocialButtons onSuccess={mockOnSuccess} />);

      fireEvent.press(getByText('Google'));

      await waitFor(() => {
        expect(mockOnSuccess).toHaveBeenCalledTimes(1);
      });
    });
  });

  describe('Apple Authentication (iOS)', () => {
    beforeEach(() => {
      Platform.OS = 'ios';
    });

    it('should call AppleAuthentication.signInAsync on iOS', async () => {
      (AppleAuthentication.signInAsync as jest.Mock).mockResolvedValueOnce({
        user: 'test-user',
        email: 'test@example.com',
        identityToken: 'test-token',
      });
      (signIn.social as jest.Mock).mockResolvedValueOnce({});

      const { getByTestId } = render(<SocialButtons />);

      fireEvent.press(getByTestId('apple-native-button'));

      await waitFor(() => {
        expect(AppleAuthentication.signInAsync).toHaveBeenCalled();
        expect(signIn.social).toHaveBeenCalledWith({
          provider: 'apple',
          idToken: 'test-token',
        });
      });
    });

    it('should trigger haptic feedback for Apple sign in', async () => {
      (AppleAuthentication.signInAsync as jest.Mock).mockResolvedValueOnce({
        identityToken: 'test-token',
      });
      (signIn.social as jest.Mock).mockResolvedValueOnce({});

      const { getByTestId } = render(<SocialButtons />);

      fireEvent.press(getByTestId('apple-native-button'));

      await waitFor(() => {
        expect(Haptics.impactAsync).toHaveBeenCalledWith(
          Haptics.ImpactFeedbackStyle.Light
        );
      });
    });
  });

  describe('Loading State', () => {
    it('should show loading indicator when authenticating', async () => {
      let resolvePromise: () => void;
      const promise = new Promise<void>((resolve) => {
        resolvePromise = resolve;
      });
      (signIn.social as jest.Mock).mockReturnValueOnce(promise);

      const { getByText, UNSAFE_queryByType } = render(<SocialButtons />);

      fireEvent.press(getByText('Google'));

      await waitFor(() => {
        const { ActivityIndicator } = require('react-native');
        expect(UNSAFE_queryByType(ActivityIndicator)).toBeTruthy();
      });

      resolvePromise!();
    });

    it('should disable buttons while loading', async () => {
      let resolvePromise: () => void;
      const promise = new Promise<void>((resolve) => {
        resolvePromise = resolve;
      });
      (signIn.social as jest.Mock).mockReturnValueOnce(promise);

      const { getByText } = render(<SocialButtons />);

      fireEvent.press(getByText('Google'));

      await waitFor(() => {
        // Try pressing again - should not trigger
        fireEvent.press(getByText('Google'));
        expect(signIn.social).toHaveBeenCalledTimes(1);
      });

      resolvePromise!();
    });
  });

  describe('Error Handling', () => {
    it('should call onError when Google auth fails', async () => {
      (signIn.social as jest.Mock).mockRejectedValueOnce(new Error('Failed'));

      const { getByText } = render(<SocialButtons onError={mockOnError} />);

      fireEvent.press(getByText('Google'));

      await waitFor(() => {
        expect(mockOnError).toHaveBeenCalledWith(
          'Failed to sign in with google. Please try again.'
        );
      });
    });

    it('should handle Apple cancellation gracefully', async () => {
      Platform.OS = 'ios';
      const cancelError = new Error('User cancelled');
      (cancelError as any).code = 'ERR_REQUEST_CANCELED';
      (AppleAuthentication.signInAsync as jest.Mock).mockRejectedValueOnce(cancelError);

      const { getByTestId } = render(<SocialButtons onError={mockOnError} />);

      fireEvent.press(getByTestId('apple-native-button'));

      await waitFor(() => {
        // Should NOT call onError for cancellation
        expect(mockOnError).not.toHaveBeenCalled();
      });
    });
  });

  describe('Disabled State', () => {
    it('should disable all buttons when disabled prop is true', () => {
      const { getByText } = render(<SocialButtons disabled />);

      fireEvent.press(getByText('Google'));

      expect(signIn.social).not.toHaveBeenCalled();
    });
  });
});
```

**Step 2: Run test to verify it fails**
- Run: `pnpm --filter klard-mobile test src/__tests__/components/auth/SocialButtons.test.tsx --run`
- Expected: FAIL (missing native Apple implementation, haptics, onSuccess).

**Step 3: Update mobile SocialButtons implementation**
Update `klard-mobile/src/components/auth/social-buttons.tsx`:

```tsx
import { useState } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  ActivityIndicator,
  Platform,
} from 'react-native';
import Svg, { Path } from 'react-native-svg';
import * as AppleAuthentication from 'expo-apple-authentication';
import * as Haptics from 'expo-haptics';
import { useThemeColors } from '@/hooks';
import { signIn } from '@/lib/auth-client';

interface SocialButtonsProps {
  disabled?: boolean;
  onError?: (error: string) => void;
  onSuccess?: () => void;
}

export function SocialButtons({ disabled, onError, onSuccess }: SocialButtonsProps) {
  const [loadingProvider, setLoadingProvider] = useState<string | null>(null);
  const colors = useThemeColors();

  async function handleGoogleLogin() {
    if (disabled || loadingProvider) return;

    try {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
      setLoadingProvider('google');
      await signIn.social({ provider: 'google' });
      onSuccess?.();
    } catch {
      onError?.('Failed to sign in with google. Please try again.');
    } finally {
      setLoadingProvider(null);
    }
  }

  async function handleAppleLogin() {
    if (disabled || loadingProvider) return;

    try {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
      setLoadingProvider('apple');

      if (Platform.OS === 'ios') {
        const credential = await AppleAuthentication.signInAsync({
          requestedScopes: [
            AppleAuthentication.AppleAuthenticationScope.FULL_NAME,
            AppleAuthentication.AppleAuthenticationScope.EMAIL,
          ],
        });

        // Send credential to backend via signIn.social
        await signIn.social({
          provider: 'apple',
          idToken: credential.identityToken,
        });
      } else {
        // Android fallback - use web-based OAuth
        await signIn.social({ provider: 'apple' });
      }
      onSuccess?.();
    } catch (error: any) {
      if (error?.code === 'ERR_REQUEST_CANCELED') {
        // User cancelled - don't show error
        return;
      }
      onError?.('Failed to sign in with apple. Please try again.');
    } finally {
      setLoadingProvider(null);
    }
  }

  const isDisabled = disabled || loadingProvider !== null;

  return (
    <View style={styles.container}>
      {/* Google Button */}
      <TouchableOpacity
        onPress={handleGoogleLogin}
        disabled={isDisabled}
        style={[
          styles.button,
          {
            borderColor: colors.border,
            opacity: isDisabled ? 0.5 : 1,
          },
        ]}
        accessibilityRole="button"
        accessibilityLabel="Sign in with Google"
      >
        {loadingProvider === 'google' ? (
          <ActivityIndicator size="small" color={colors.foreground} />
        ) : (
          <View style={styles.buttonContent}>
            <GoogleIcon />
            <Text style={[styles.buttonText, { color: colors.foreground }]}>
              Google
            </Text>
          </View>
        )}
      </TouchableOpacity>

      {/* Apple Button - Native on iOS, Custom on Android */}
      {Platform.OS === 'ios' ? (
        <AppleAuthentication.AppleAuthenticationButton
          buttonType={AppleAuthentication.AppleAuthenticationButtonType.SIGN_IN}
          buttonStyle={AppleAuthentication.AppleAuthenticationButtonStyle.BLACK}
          cornerRadius={12}
          style={[styles.appleButton, { opacity: isDisabled ? 0.5 : 1 }]}
          onPress={handleAppleLogin}
          testID="apple-native-button"
        />
      ) : (
        <TouchableOpacity
          onPress={handleAppleLogin}
          disabled={isDisabled}
          style={[
            styles.button,
            {
              borderColor: colors.border,
              opacity: isDisabled ? 0.5 : 1,
            },
          ]}
          accessibilityRole="button"
          accessibilityLabel="Sign in with Apple"
        >
          {loadingProvider === 'apple' ? (
            <ActivityIndicator size="small" color={colors.foreground} />
          ) : (
            <View style={styles.buttonContent}>
              <AppleIcon color={colors.foreground} />
              <Text style={[styles.buttonText, { color: colors.foreground }]}>
                Apple
              </Text>
            </View>
          )}
        </TouchableOpacity>
      )}
    </View>
  );
}

function GoogleIcon() {
  return (
    <Svg width={20} height={20} viewBox="0 0 24 24" fill="none">
      <Path
        d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
        fill="#4285F4"
      />
      <Path
        d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
        fill="#34A853"
      />
      <Path
        d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
        fill="#FBBC05"
      />
      <Path
        d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
        fill="#EA4335"
      />
    </Svg>
  );
}

function AppleIcon({ color }: { color: string }) {
  return (
    <Svg width={20} height={20} viewBox="0 0 24 24" fill={color}>
      <Path d="M17.05 20.28c-.98.95-2.05.8-3.08.35-1.09-.46-2.09-.48-3.24 0-1.44.62-2.2.44-3.06-.35C2.79 15.25 3.51 7.59 9.05 7.31c1.35.07 2.29.74 3.08.8 1.18-.24 2.31-.93 3.57-.84 1.51.12 2.65.72 3.4 1.8-3.12 1.87-2.38 5.98.48 7.13-.57 1.5-1.31 2.99-2.54 4.09l.01-.01zM12.03 7.25c-.15-2.23 1.66-4.07 3.74-4.25.29 2.58-2.34 4.5-3.74 4.25z" />
    </Svg>
  );
}

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    gap: 16,
  },
  button: {
    flex: 1,
    height: 48,
    borderRadius: 12,
    borderWidth: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  appleButton: {
    flex: 1,
    height: 48,
  },
  buttonContent: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  buttonText: {
    fontSize: 16,
    fontWeight: '500',
  },
});
```

**Step 4: Run test to verify it passes**
- Run: `pnpm --filter klard-mobile test src/__tests__/components/auth/SocialButtons.test.tsx --run`
- Expected: PASS.

**Step 5: Commit**
- `git add klard-mobile/src/__tests__/components/auth/SocialButtons.test.tsx klard-mobile/src/components/auth/social-buttons.tsx`
- `git commit -m "feat(mobile): add native Apple Sign In, haptics, and comprehensive tests"`

---

### Task 4: TypeScript Verification

**Files:**
- None (verification only)

**Step 1: Run TypeScript check on web**
```bash
pnpm --filter klard-web exec tsc --noEmit
```
Expected: No errors

**Step 2: Run TypeScript check on mobile**
```bash
pnpm --filter klard-mobile exec tsc --noEmit
```
Expected: No errors

**Step 3: Commit if any fixes were needed**
If type errors found, fix them and commit:
```bash
git add [fixed-files]
git commit -m "fix(types): resolve TypeScript errors in social login components"
```

---

### Task 5: Update Spec Marker

**Files:**
- Modify: `docs/screens/batch/Klard_Component_Specifications.md`

**Step 1: Update marker**
Replace `<!-- IN-PROGRESS:6.1-oauth-social-login -->` with `<!-- DONE:6.1-oauth-social-login -->`

**Step 2: Commit**
```bash
git add docs/screens/batch/Klard_Component_Specifications.md
git commit -m "docs: mark 6.1-oauth-social-login as DONE"
```

---

## Verification Checklist

Before marking complete, verify:

- [ ] SocialButton (web) renders without errors
- [ ] SocialButton (web) all tests pass (rendering, loading, disabled, click, styling, edge cases)
- [ ] SocialButtons (web) renders without errors
- [ ] SocialButtons (web) all tests pass (rendering, auth flow, loading, error, success, disabled)
- [ ] SocialButtons (mobile) renders without errors
- [ ] SocialButtons (mobile) uses native Apple button on iOS
- [ ] SocialButtons (mobile) all tests pass (rendering, Google auth, Apple auth, loading, error, haptics, disabled)
- [ ] TypeScript passes with no errors (web)
- [ ] TypeScript passes with no errors (mobile)
- [ ] Existing exports maintained in ui/index.ts (if applicable)
- [ ] Spec marker updated to DONE

---

## Summary

| Task | Description | Files |
|------|-------------|-------|
| 1 | Web SocialButton primitive tests | `klard-web/src/__tests__/components/ui/social-button.test.tsx`, `klard-web/src/components/ui/social-button.tsx` |
| 2 | Web SocialButtons container tests + onSuccess | `klard-web/src/__tests__/components/auth/social-buttons.test.tsx`, `klard-web/src/components/auth/social-buttons.tsx` |
| 3 | Mobile SocialButtons tests + native Apple + haptics | `klard-mobile/src/__tests__/components/auth/SocialButtons.test.tsx`, `klard-mobile/src/components/auth/social-buttons.tsx` |
| 4 | TypeScript verification | - |
| 5 | Update spec marker | `docs/screens/batch/Klard_Component_Specifications.md` |

---

## Notes

- Keep data-slot attributes for traceability on web components.
- Avoid mocks that hide side effects; tests call real component logic with mocked auth client only.
- Ensure Apple button uses Expo native component for guideline compliance and guard unavailability to avoid crashes on Android.
- Haptic feedback enhances mobile UX and should trigger before auth flow starts.
- Handle Apple cancellation gracefully (ERR_REQUEST_CANCELED) without showing error to user.
- Both platforms support onSuccess callback for navigation or UI updates after successful authentication.