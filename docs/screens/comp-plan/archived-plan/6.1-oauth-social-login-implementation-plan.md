# 6.1 OAuth / Social Login Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Deliver production-ready social authentication buttons (Google + Apple) for web and mobile with full TDD coverage, proper loading/disabled/error handling, and platform-appropriate flows using the existing auth client.

**Architecture:** Two-layer structure: a primitive `SocialButton` (web) or platform button renders provider-specific UI, while a composed `SocialButtons` container manages async login state, dispatches `signIn.social`, and surfaces errors via `onError`. Mobile wraps Apple native button when available and uses auth client flows via Expo integrations.

**Tech Stack:** Next.js 16 + React 19 + shadcn/ui + better-auth client + Vitest/RTL (web); Expo 54 + React Native + expo-apple-authentication + expo-web-browser + better-auth/expo + Jest/RNTL (mobile).

---

## Plan Content

- **Component:** OAuth / Social Login (Google + Apple)
- **Target platforms:** Web and Mobile
- **Props interface (container):** `disabled?: boolean; onError?: (message: string) => void; onSuccess?: () => void` (web/mobile symmetry), internal provider config array.
- **Visual states:** default, hover/focus (web), pressed/active, disabled, loading (per-provider), error surfaced via `onError` callback (caller renders message).
- **Size/spacing:** 48px height (web), 12px radius, gap-8 icon/text, full-width container with 12-16px gaps; mobile uses StyleSheet with 48px height, radius 12, gap 8.
- **Color tokens:** Web uses shadcn variants + Klard tokens (`text-foreground`, `border-border`, muted hover, primary focus outline); Mobile uses `useThemeColors` for `foreground`, `border`.
- **Accessibility:** `role="button"`/`accessibilityRole="button"`, `aria-label`/`accessibilityLabel` like “Continue with Google”, keyboard focus ring on web, ensure Apple button only when available/Platform iOS.
- **Dependencies:** Web: `@/lib/auth-client` (`signIn`), `@/components/ui/social-button`, `@/components/ui/icons`; Mobile: `@/lib/auth-client` (`signIn`), `expo-apple-authentication`, `expo-web-browser` (for future compatibility), `expo-linking` (redirect handling if needed), `useThemeColors`.
- **SOLID compliance:**

| Component | SRP | OCP | LSP | ISP | DIP |
|-----------|-----|-----|-----|-----|-----|
| SocialButton (web) | Render one provider button statefully | Extend via props/styles | Button remains substitutable | Minimal props used | Depends on props + utils |
| SocialButtons (web) | Manage auth flow + loading gating | Add providers via data array | Composition, not inheritance | Narrow props (disabled/onError/onSuccess) | Depends on `signIn` abstraction |
| SocialButtons (mobile) | Manage auth flow + platform gating | Providers added via config | Composition | Minimal props | Depends on auth client + Expo APIs abstractions |

- **Parallel sub-agent strategy:** Tasks are independent (web tests/impl vs mobile tests/impl). Execute sequentially in this session (subagent tooling unavailable in Codex; I will perform each “subagent” task myself and review between tasks).
- **Test strategy (TDD first):**
  - Web: new tests for container behavior (provider renders, loading disables peers, calls `signIn.social`, error callback, data-slot, spinner visibility).
  - Mobile: tests for provider rendering, Apple availability gating, loading disable, error callback, signIn invocation. Mock Expo modules (apple auth availability + sign-in) and `signIn.social`.

---

## Bite-Sized Tasks

### Task 1: Web – Write failing tests for Social Login

**Files:**
- Create: `klard-web/src/__tests__/components/auth/social-buttons.test.tsx`

**Step 1: Write the failing test**
```tsx
/**
 * SocialButtons web tests
 * 1) Renders Google + Apple buttons with correct labels and data-slot
 * 2) Calls signIn.social with provider id
 * 3) Loading state shows spinner and disables both buttons
 * 4) Disabled prop prevents interaction
 * 5) Errors surface via onError callback
 */
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { SocialButtons } from '@/components/auth/social-buttons';
import { signIn } from '@/lib/auth-client';

vi.mock('@/lib/auth-client', () => ({
  signIn: { social: vi.fn() },
}));

const renderSocialButtons = (props: Partial<React.ComponentProps<typeof SocialButtons>> = {}) =>
  render(<SocialButtons {...props} />);

describe('SocialButtons (web)', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('renders Google and Apple buttons with accessible labels', () => {
    renderSocialButtons();

    expect(screen.getByRole('button', { name: /google/i })).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /apple/i })).toBeInTheDocument();
  });

  it('sets data-slot for traceability', () => {
    renderSocialButtons();

    expect(screen.getByRole('button', { name: /google/i })).toHaveAttribute('data-slot', 'social-button');
  });

  it('calls signIn.social with google provider on click', async () => {
    (signIn.social as unknown as ReturnType<typeof vi.fn>).mockResolvedValueOnce({});
    renderSocialButtons();

    fireEvent.click(screen.getByRole('button', { name: /google/i }));

    await waitFor(() => {
      expect(signIn.social).toHaveBeenCalledWith({ provider: 'google' });
    });
  });

  it('shows spinner and disables both buttons while loading', async () => {
    let resolvePromise: () => void;
    const promise = new Promise((resolve) => { resolvePromise = resolve; });
    (signIn.social as unknown as ReturnType<typeof vi.fn>).mockReturnValueOnce(promise);
    renderSocialButtons();

    fireEvent.click(screen.getByRole('button', { name: /apple/i }));

    const google = screen.getByRole('button', { name: /google/i });
    const apple = screen.getByRole('button', { name: /apple/i });
    expect(google).toBeDisabled();
    expect(apple).toBeDisabled();
    expect(apple.querySelector('svg') || apple.querySelector('[data-testid="spinner"]')).toBeTruthy();

    resolvePromise!();
  });

  it('does not call sign-in when disabled prop is true', () => {
    renderSocialButtons({ disabled: true });

    fireEvent.click(screen.getByRole('button', { name: /google/i }));
    expect(signIn.social).not.toHaveBeenCalled();
  });

  it('invokes onError with provider-specific message when sign-in fails', async () => {
    const onError = vi.fn();
    (signIn.social as unknown as ReturnType<typeof vi.fn>).mockRejectedValueOnce(new Error('fail'));
    renderSocialButtons({ onError });

    fireEvent.click(screen.getByRole('button', { name: /apple/i }));

    await waitFor(() => {
      expect(onError).toHaveBeenCalledWith('Failed to sign in with apple. Please try again.');
    });
  });
});
```

**Step 2: Run test to verify it fails**
- Run: `pnpm --filter klard-web test src/__tests__/components/auth/social-buttons.test.tsx --run`
- Expected: FAIL (missing test file implementation/behaviors).

**Step 3: Write minimal implementation**
- Update `klard-web/src/components/auth/social-buttons.tsx` to:
  - Keep provider config, add `data-slot="social-button"` to buttons.
  - Accept optional `onSuccess` callback.
  - Ensure `type="button"` and focus states via className.
  - Disable both buttons when any provider loading or when `disabled` prop true.
  - Surface errors via `onError` with provider name; reset loading in finally.
- Update `klard-web/src/components/ui/social-button.tsx` to:
  - Add `data-slot="social-button"`, `aria-label` fallback to provider text.
  - Guard click when disabled/loading.
  - Ensure spinner includes `data-testid="spinner"` for detection.

**Step 4: Run test to verify it passes**
- Run: `pnpm --filter klard-web test src/__tests__/components/auth/social-buttons.test.tsx --run`
- Expected: PASS.

**Step 5: Commit**
- `git add klard-web/src/components/auth/social-buttons.tsx klard-web/src/components/ui/social-button.tsx klard-web/src/__tests__/components/auth/social-buttons.test.tsx`
- `git commit -m "feat(web): add social login buttons tests and loading guard"`

---

### Task 2: Mobile – Write failing tests for Social Login

**Files:**
- Create: `klard-mobile/src/__tests__/components/auth/SocialButtons.test.tsx` (create `auth` dir)

**Step 1: Write the failing test**
```tsx
/**
 * SocialButtons mobile tests
 * 1) Renders Google + Apple buttons (Apple gated by iOS + availability)
 * 2) Calls signIn.social with provider
 * 3) Loading disables both buttons and shows ActivityIndicator
 * 4) Disabled prop prevents calls
 * 5) Errors bubble via onError
 */
import React from 'react';
import { render, fireEvent, waitFor } from '@testing-library/react-native';
import { Platform } from 'react-native';
import { SocialButtons } from '@/components/auth/social-buttons';
import { signIn } from '@/lib/auth-client';
import * as AppleAuthentication from 'expo-apple-authentication';

jest.mock('@/lib/auth-client', () => ({
  signIn: { social: jest.fn() },
}));

jest.mock('expo-apple-authentication', () => ({
  __esModule: true,
  ...jest.requireActual('expo-apple-authentication'),
  isAvailableAsync: jest.fn(),
  AppleAuthenticationButton: ({ onPress, testID }: any) => (
    <button testID={testID || 'apple-button'} onClick={onPress}>Apple</button>
  ),
  AppleAuthenticationButtonType: { SIGN_IN: 'SIGN_IN' },
  AppleAuthenticationButtonStyle: { BLACK: 'BLACK' },
  AppleAuthenticationScope: { FULL_NAME: 'FULL_NAME', EMAIL: 'EMAIL' },
}));

describe('SocialButtons (mobile)', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    (Platform as any).OS = 'ios';
    (AppleAuthentication.isAvailableAsync as jest.Mock).mockResolvedValue(true);
  });

  it('renders Google and Apple buttons on iOS when available', async () => {
    const { getByText, findByTestId } = render(<SocialButtons />);

    expect(getByText(/google/i)).toBeTruthy();
    expect(await findByTestId('apple-button')).toBeTruthy();
  });

  it('hides Apple button when not available', async () => {
    (AppleAuthentication.isAvailableAsync as jest.Mock).mockResolvedValueOnce(false);
    const { queryByTestId } = render(<SocialButtons />);

    await waitFor(() => expect(queryByTestId('apple-button')).toBeNull());
  });

  it('calls signIn.social with google', async () => {
    (signIn.social as jest.Mock).mockResolvedValueOnce({});
    const { getByText } = render(<SocialButtons />);

    fireEvent.press(getByText(/google/i));

    await waitFor(() => {
      expect(signIn.social).toHaveBeenCalledWith({ provider: 'google' });
    });
  });

  it('disables both buttons and shows loading during request', async () => {
    let resolvePromise: () => void;
    const promise = new Promise((resolve) => { resolvePromise = resolve; });
    (signIn.social as jest.Mock).mockReturnValueOnce(promise);
    const { getByText } = render(<SocialButtons />);

    fireEvent.press(getByText(/apple/i));

    const google = getByText(/google/i);
    expect((google.props as any).disabled).toBe(true);
    resolvePromise!();
  });

  it('does not invoke sign-in when disabled prop is set', () => {
    const { getByText } = render(<SocialButtons disabled />);

    fireEvent.press(getByText(/google/i));
    expect(signIn.social).not.toHaveBeenCalled();
  });

  it('surfaces errors via onError', async () => {
    const onError = jest.fn();
    (signIn.social as jest.Mock).mockRejectedValueOnce(new Error('fail'));
    const { getByText } = render(<SocialButtons onError={onError} />);

    fireEvent.press(getByText(/google/i));

    await waitFor(() => {
      expect(onError).toHaveBeenCalledWith('Failed to sign in with google. Please try again.');
    });
  });
});
```

**Step 2: Run test to verify it fails**
- Run: `pnpm --filter klard-mobile test src/__tests__/components/auth/SocialButtons.test.tsx --run`
- Expected: FAIL (missing file/behaviors).

**Step 3: Write minimal implementation**
- Update `klard-mobile/src/components/auth/social-buttons.tsx`:
  - Add `onSuccess?` and disable guard; centralize provider config.
  - Track `loadingProvider` and disable both when set.
  - On iOS, call `AppleAuthentication.isAvailableAsync()` in effect; render `AppleAuthenticationButton` when available, otherwise skip.
  - Preserve Google button via TouchableOpacity with ActivityIndicator when loading.
  - Call `onError` with provider label on failure; invoke `onSuccess` on resolve.
  - Ensure `accessibilityLabel` like “Continue with Google”.
- Add `testID` for Apple button when using Expo component for test targeting.

**Step 4: Run test to verify it passes**
- Run: `pnpm --filter klard-mobile test src/__tests__/components/auth/SocialButtons.test.tsx --run`
- Expected: PASS.

**Step 5: Commit**
- `git add klard-mobile/src/components/auth/social-buttons.tsx klard-mobile/src/__tests__/components/auth/SocialButtons.test.tsx`
- `git commit -m "feat(mobile): add social login buttons tests and platform handling"`

---

### Task 3: Verification & spec status

**Files:**
- Modify: `docs/screens/batch/Klard_Component_Specifications.md` (IN-PROGRESS already set; swap to DONE after tests pass)

**Step 1: Run focused verifications**
- Web tests: `pnpm --filter klard-web test src/__tests__/components/auth/social-buttons.test.tsx --run`
- Mobile tests: `pnpm --filter klard-mobile test src/__tests__/components/auth/SocialButtons.test.tsx --run`
- Type checks (targeted): `pnpm --filter klard-web exec tsc --noEmit` and `pnpm --filter klard-mobile exec tsc --noEmit`

**Step 2: Update spec marker**
- Replace `<!-- IN-PROGRESS:6.1-oauth-social-login -->` with `<!-- DONE:6.1-oauth-social-login -->` in `docs/screens/batch/Klard_Component_Specifications.md`.

**Step 3: Commit**
- `git add docs/screens/batch/Klard_Component_Specifications.md`
- `git commit -m "docs: mark oauth social login component complete"`

---

## Notes
- Keep data-slot attributes for traceability.
- Avoid mocks that hide side effects; tests call real component logic with mocked auth client only.
- Ensure Apple button uses Expo component for guideline compliance and guard unavailability to avoid crashes on Android.
