# SegmentedControl Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a reusable SegmentedControl component for mutually exclusive option selection on both Web (Next.js + shadcn/ui) and Mobile (Expo SDK 54).

**Architecture:** Web uses shadcn/ui Tabs components styled as a segmented control. Mobile uses platform-native pickers (@expo/ui/swift-ui for iOS, custom Pressable-based fallback for cross-platform since @expo/ui is experimental).

**Tech Stack:** Web: React 19, shadcn/ui Tabs, CVA, Tailwind CSS 4. Mobile: React Native, Expo SDK 54, expo-haptics, StyleSheet.

---

## SOLID Compliance

| Component | SRP | OCP | LSP | ISP | DIP |
|-----------|-----|-----|-----|-----|-----|
| SegmentedControl (Web) | Renders segmented options only | Extensible via options array | Handles all option types | Single focused interface | Depends on option type abstraction |
| SegmentedControl (Mobile) | Renders segmented options only | Extensible via options array | Handles all option types | Single focused interface | Depends on option type abstraction |

### Principle Applications

**SRP:** Each component does ONE thing - renders a segmented control for option selection
**OCP:** Options are passed via props array - extend by adding options, not modifying component
**LSP:** Component accepts any valid option array conforming to the interface
**ISP:** Interface contains only necessary props (value, onChange, options, size, fullWidth)
**DIP:** Component depends on option interface abstraction, not concrete implementations

---

## Props Interface (shared)

```typescript
interface SegmentedControlOption {
  value: string;
  label: string;
  icon?: React.ReactNode;
}

interface SegmentedControlProps {
  value: string;
  onChange: (value: string) => void;
  options: SegmentedControlOption[];
  size?: 'sm' | 'md';
  fullWidth?: boolean;
  disabled?: boolean;
  testID?: string; // Mobile only
  className?: string; // Web only
}
```

---

## Task 1: Write Web Component Tests

**Files:**
- Create: `klard-web/src/__tests__/components/ui/segmented-control.test.tsx`

**Step 1: Write the failing tests**

```tsx
/**
 * Tests for SegmentedControl Component (Web)
 *
 * TDD: Write failing tests first, then implement to pass.
 * Tests verify: rendering, selection, variants, sizes, fullWidth, accessibility
 */

import { describe, it, expect, vi } from "vitest"
import { render, screen, fireEvent } from "@testing-library/react"
import { SegmentedControl } from "@/components/ui/segmented-control"

const defaultOptions = [
  { value: "option1", label: "Option 1" },
  { value: "option2", label: "Option 2" },
  { value: "option3", label: "Option 3" },
]

describe("SegmentedControl", () => {
  describe("Rendering", () => {
    it("should render all options", () => {
      render(
        <SegmentedControl
          value="option1"
          onChange={() => {}}
          options={defaultOptions}
        />
      )

      expect(screen.getByText("Option 1")).toBeInTheDocument()
      expect(screen.getByText("Option 2")).toBeInTheDocument()
      expect(screen.getByText("Option 3")).toBeInTheDocument()
    })

    it("should have data-slot attribute", () => {
      render(
        <SegmentedControl
          value="option1"
          onChange={() => {}}
          options={defaultOptions}
        />
      )

      expect(
        document.querySelector('[data-slot="segmented-control"]')
      ).toBeInTheDocument()
    })

    it("should render with correct accessibility role", () => {
      render(
        <SegmentedControl
          value="option1"
          onChange={() => {}}
          options={defaultOptions}
        />
      )

      expect(screen.getByRole("tablist")).toBeInTheDocument()
    })
  })

  describe("Selection", () => {
    it("should highlight the selected option", () => {
      render(
        <SegmentedControl
          value="option2"
          onChange={() => {}}
          options={defaultOptions}
        />
      )

      const selectedTab = screen.getByRole("tab", { name: "Option 2" })
      expect(selectedTab).toHaveAttribute("data-state", "active")
    })

    it("should call onChange when an option is clicked", () => {
      const handleChange = vi.fn()
      render(
        <SegmentedControl
          value="option1"
          onChange={handleChange}
          options={defaultOptions}
        />
      )

      fireEvent.click(screen.getByText("Option 2"))

      expect(handleChange).toHaveBeenCalledWith("option2")
    })

    it("should not call onChange when clicking already selected option", () => {
      const handleChange = vi.fn()
      render(
        <SegmentedControl
          value="option1"
          onChange={handleChange}
          options={defaultOptions}
        />
      )

      fireEvent.click(screen.getByText("Option 1"))

      // Tabs don't call onChange when clicking already selected
      expect(handleChange).not.toHaveBeenCalled()
    })
  })

  describe("Sizes", () => {
    it("should render with md size by default", () => {
      render(
        <SegmentedControl
          value="option1"
          onChange={() => {}}
          options={defaultOptions}
        />
      )

      const tabsList = screen.getByRole("tablist")
      expect(tabsList.className).toMatch(/h-10/)
    })

    it("should render with sm size when specified", () => {
      render(
        <SegmentedControl
          value="option1"
          onChange={() => {}}
          options={defaultOptions}
          size="sm"
        />
      )

      const tabsList = screen.getByRole("tablist")
      expect(tabsList.className).toMatch(/h-8/)
    })
  })

  describe("Full Width", () => {
    it("should not be full width by default", () => {
      render(
        <SegmentedControl
          value="option1"
          onChange={() => {}}
          options={defaultOptions}
        />
      )

      const container = document.querySelector('[data-slot="segmented-control"]')
      expect(container?.className).not.toMatch(/w-full/)
    })

    it("should be full width when fullWidth is true", () => {
      render(
        <SegmentedControl
          value="option1"
          onChange={() => {}}
          options={defaultOptions}
          fullWidth
        />
      )

      const container = document.querySelector('[data-slot="segmented-control"]')
      expect(container?.className).toMatch(/w-full/)
    })

    it("should have flex-1 on triggers when fullWidth", () => {
      render(
        <SegmentedControl
          value="option1"
          onChange={() => {}}
          options={defaultOptions}
          fullWidth
        />
      )

      const tabs = screen.getAllByRole("tab")
      tabs.forEach((tab) => {
        expect(tab.className).toMatch(/flex-1/)
      })
    })
  })

  describe("Icons", () => {
    it("should render icon when provided", () => {
      const optionsWithIcon = [
        { value: "opt1", label: "With Icon", icon: <span data-testid="test-icon">★</span> },
        { value: "opt2", label: "No Icon" },
      ]

      render(
        <SegmentedControl
          value="opt1"
          onChange={() => {}}
          options={optionsWithIcon}
        />
      )

      expect(screen.getByTestId("test-icon")).toBeInTheDocument()
    })

    it("should render icon before label", () => {
      const optionsWithIcon = [
        { value: "opt1", label: "Label", icon: <span data-testid="icon">I</span> },
      ]

      render(
        <SegmentedControl
          value="opt1"
          onChange={() => {}}
          options={optionsWithIcon}
        />
      )

      const tab = screen.getByRole("tab")
      const icon = screen.getByTestId("icon")
      const label = screen.getByText("Label")

      // Icon should come before label in DOM
      expect(tab.innerHTML.indexOf("icon")).toBeLessThan(
        tab.innerHTML.indexOf("Label")
      )
    })
  })

  describe("Disabled State", () => {
    it("should disable all tabs when disabled is true", () => {
      render(
        <SegmentedControl
          value="option1"
          onChange={() => {}}
          options={defaultOptions}
          disabled
        />
      )

      const tabs = screen.getAllByRole("tab")
      tabs.forEach((tab) => {
        expect(tab).toBeDisabled()
      })
    })

    it("should not call onChange when disabled", () => {
      const handleChange = vi.fn()
      render(
        <SegmentedControl
          value="option1"
          onChange={handleChange}
          options={defaultOptions}
          disabled
        />
      )

      fireEvent.click(screen.getByText("Option 2"))

      expect(handleChange).not.toHaveBeenCalled()
    })
  })

  describe("Custom className", () => {
    it("should merge custom className", () => {
      render(
        <SegmentedControl
          value="option1"
          onChange={() => {}}
          options={defaultOptions}
          className="custom-class"
        />
      )

      const container = document.querySelector('[data-slot="segmented-control"]')
      expect(container?.className).toContain("custom-class")
    })
  })

  describe("Edge Cases", () => {
    it("should handle single option", () => {
      render(
        <SegmentedControl
          value="only"
          onChange={() => {}}
          options={[{ value: "only", label: "Only Option" }]}
        />
      )

      expect(screen.getByText("Only Option")).toBeInTheDocument()
    })

    it("should handle empty options gracefully", () => {
      render(
        <SegmentedControl value="" onChange={() => {}} options={[]} />
      )

      expect(screen.getByRole("tablist")).toBeInTheDocument()
    })
  })
})
```

**Step 2: Run test to verify it fails**

Run: `pnpm --filter klard-web test src/__tests__/components/ui/segmented-control.test.tsx --run`
Expected: FAIL with "Cannot find module '@/components/ui/segmented-control'"

**Step 3: Continue to Task 2**

---

## Task 2: Implement Web Component

**Files:**
- Create: `klard-web/src/components/ui/segmented-control.tsx`
- Modify: `klard-web/src/components/ui/index.ts`

**Step 1: Create the component**

```tsx
"use client"

import * as React from "react"
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const segmentedControlVariants = cva("", {
  variants: {
    size: {
      sm: "",
      md: "",
    },
    fullWidth: {
      true: "w-full",
      false: "",
    },
  },
  defaultVariants: {
    size: "md",
    fullWidth: false,
  },
})

const tabsListVariants = cva(
  "bg-slate-100 dark:bg-slate-800",
  {
    variants: {
      size: {
        sm: "h-8",
        md: "h-10",
      },
      fullWidth: {
        true: "w-full",
        false: "",
      },
    },
    defaultVariants: {
      size: "md",
      fullWidth: false,
    },
  }
)

const tabsTriggerVariants = cva(
  "data-[state=active]:bg-white data-[state=active]:text-teal-700 dark:data-[state=active]:bg-slate-950 dark:data-[state=active]:text-teal-400",
  {
    variants: {
      size: {
        sm: "text-sm px-2",
        md: "text-sm px-3",
      },
      fullWidth: {
        true: "flex-1",
        false: "",
      },
    },
    defaultVariants: {
      size: "md",
      fullWidth: false,
    },
  }
)

export interface SegmentedControlOption {
  value: string
  label: string
  icon?: React.ReactNode
}

export interface SegmentedControlProps
  extends VariantProps<typeof segmentedControlVariants> {
  value: string
  onChange: (value: string) => void
  options: SegmentedControlOption[]
  disabled?: boolean
  className?: string
}

function SegmentedControl({
  value,
  onChange,
  options,
  size,
  fullWidth,
  disabled = false,
  className,
}: SegmentedControlProps) {
  return (
    <Tabs
      value={value}
      onValueChange={onChange}
      data-slot="segmented-control"
      className={cn(segmentedControlVariants({ size, fullWidth }), className)}
    >
      <TabsList className={cn(tabsListVariants({ size, fullWidth }))}>
        {options.map((option) => (
          <TabsTrigger
            key={option.value}
            value={option.value}
            disabled={disabled}
            className={cn(tabsTriggerVariants({ size, fullWidth }))}
          >
            {option.icon && <span className="shrink-0 mr-1.5">{option.icon}</span>}
            {option.label}
          </TabsTrigger>
        ))}
      </TabsList>
    </Tabs>
  )
}

export { SegmentedControl, segmentedControlVariants }
```

**Step 2: Export from index.ts**

Add to `klard-web/src/components/ui/index.ts`:

```typescript
export {
  SegmentedControl,
  segmentedControlVariants,
  type SegmentedControlProps,
  type SegmentedControlOption,
} from './segmented-control';
```

**Step 3: Run tests to verify they pass**

Run: `pnpm --filter klard-web test src/__tests__/components/ui/segmented-control.test.tsx --run`
Expected: PASS (all tests green)

**Step 4: Type check**

Run: `pnpm --filter klard-web exec tsc --noEmit`
Expected: No errors

**Step 5: Commit**

```bash
git add klard-web/src/components/ui/segmented-control.tsx klard-web/src/components/ui/index.ts klard-web/src/__tests__/components/ui/segmented-control.test.tsx
git commit -m "feat(web): add SegmentedControl component with TDD"
```

---

## Task 3: Write Mobile Component Tests

**Files:**
- Create: `klard-mobile/src/__tests__/components/ui/SegmentedControl.test.tsx`

**Step 1: Write the failing tests**

```tsx
/**
 * Tests for SegmentedControl Component (Mobile)
 *
 * TDD: Write failing tests first, then implement to pass.
 */

import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react-native';
import { Text } from 'react-native';
import { SegmentedControl } from '@/components/ui/SegmentedControl';
import * as Haptics from 'expo-haptics';

// Mock expo-haptics
jest.mock('expo-haptics', () => ({
  impactAsync: jest.fn(),
  ImpactFeedbackStyle: {
    Light: 'light',
    Medium: 'medium',
    Heavy: 'heavy',
  },
}));

const defaultOptions = [
  { value: 'option1', label: 'Option 1' },
  { value: 'option2', label: 'Option 2' },
  { value: 'option3', label: 'Option 3' },
];

describe('SegmentedControl', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('Rendering', () => {
    it('should render all options', () => {
      render(
        <SegmentedControl
          value="option1"
          onChange={() => {}}
          options={defaultOptions}
        />
      );

      expect(screen.getByText('Option 1')).toBeTruthy();
      expect(screen.getByText('Option 2')).toBeTruthy();
      expect(screen.getByText('Option 3')).toBeTruthy();
    });

    it('should render with testID when provided', () => {
      render(
        <SegmentedControl
          value="option1"
          onChange={() => {}}
          options={defaultOptions}
          testID="segmented-control"
        />
      );

      expect(screen.getByTestId('segmented-control')).toBeTruthy();
    });

    it('should have correct accessibility role', () => {
      render(
        <SegmentedControl
          value="option1"
          onChange={() => {}}
          options={defaultOptions}
          testID="segmented"
        />
      );

      const container = screen.getByTestId('segmented');
      expect(container.props.accessibilityRole).toBe('tablist');
    });
  });

  describe('Selection', () => {
    it('should highlight the selected option visually', () => {
      const { getByTestId } = render(
        <SegmentedControl
          value="option2"
          onChange={() => {}}
          options={defaultOptions}
          testID="segmented"
        />
      );

      // The selected segment should have different styling
      const segment = getByTestId('segment-option2');
      expect(segment).toBeTruthy();
    });

    it('should call onChange when an option is pressed', async () => {
      const handleChange = jest.fn();
      render(
        <SegmentedControl
          value="option1"
          onChange={handleChange}
          options={defaultOptions}
        />
      );

      fireEvent.press(screen.getByText('Option 2'));

      await waitFor(() => {
        expect(handleChange).toHaveBeenCalledWith('option2');
      });
    });

    it('should trigger haptic feedback on selection', async () => {
      const handleChange = jest.fn();
      render(
        <SegmentedControl
          value="option1"
          onChange={handleChange}
          options={defaultOptions}
        />
      );

      fireEvent.press(screen.getByText('Option 2'));

      await waitFor(() => {
        expect(Haptics.impactAsync).toHaveBeenCalledWith(
          Haptics.ImpactFeedbackStyle.Light
        );
      });
    });
  });

  describe('Sizes', () => {
    it('should render with md size by default', () => {
      render(
        <SegmentedControl
          value="option1"
          onChange={() => {}}
          options={defaultOptions}
          testID="segmented"
        />
      );

      expect(screen.getByTestId('segmented')).toBeTruthy();
    });

    it('should render with sm size when specified', () => {
      render(
        <SegmentedControl
          value="option1"
          onChange={() => {}}
          options={defaultOptions}
          size="sm"
          testID="segmented"
        />
      );

      expect(screen.getByTestId('segmented')).toBeTruthy();
    });
  });

  describe('Icons', () => {
    it('should render icon when provided', () => {
      const optionsWithIcon = [
        { value: 'opt1', label: 'With Icon', icon: <Text testID="test-icon">★</Text> },
        { value: 'opt2', label: 'No Icon' },
      ];

      render(
        <SegmentedControl
          value="opt1"
          onChange={() => {}}
          options={optionsWithIcon}
        />
      );

      expect(screen.getByTestId('test-icon')).toBeTruthy();
    });

    it('should render both icon and label', () => {
      const optionsWithIcon = [
        { value: 'opt1', label: 'Label', icon: <Text testID="icon">I</Text> },
      ];

      render(
        <SegmentedControl
          value="opt1"
          onChange={() => {}}
          options={optionsWithIcon}
        />
      );

      expect(screen.getByTestId('icon')).toBeTruthy();
      expect(screen.getByText('Label')).toBeTruthy();
    });
  });

  describe('Disabled State', () => {
    it('should not call onChange when disabled', async () => {
      const handleChange = jest.fn();
      render(
        <SegmentedControl
          value="option1"
          onChange={handleChange}
          options={defaultOptions}
          disabled
        />
      );

      fireEvent.press(screen.getByText('Option 2'));

      await waitFor(() => {
        expect(handleChange).not.toHaveBeenCalled();
      });
    });

    it('should not trigger haptics when disabled', async () => {
      render(
        <SegmentedControl
          value="option1"
          onChange={() => {}}
          options={defaultOptions}
          disabled
        />
      );

      fireEvent.press(screen.getByText('Option 2'));

      await waitFor(() => {
        expect(Haptics.impactAsync).not.toHaveBeenCalled();
      });
    });
  });

  describe('Edge Cases', () => {
    it('should handle single option', () => {
      render(
        <SegmentedControl
          value="only"
          onChange={() => {}}
          options={[{ value: 'only', label: 'Only Option' }]}
        />
      );

      expect(screen.getByText('Only Option')).toBeTruthy();
    });

    it('should handle empty options gracefully', () => {
      render(
        <SegmentedControl
          value=""
          onChange={() => {}}
          options={[]}
          testID="empty-segmented"
        />
      );

      expect(screen.getByTestId('empty-segmented')).toBeTruthy();
    });
  });
});
```

**Step 2: Run test to verify it fails**

Run: `pnpm --filter klard-mobile test src/__tests__/components/ui/SegmentedControl.test.tsx --run`
Expected: FAIL with "Cannot find module '@/components/ui/SegmentedControl'"

**Step 3: Continue to Task 4**

---

## Task 4: Implement Mobile Component

**Files:**
- Create: `klard-mobile/src/components/ui/SegmentedControl.tsx`
- Modify: `klard-mobile/src/components/ui/index.ts`

**Step 1: Create the component**

```tsx
import React from 'react';
import {
  View,
  Text,
  Pressable,
  StyleSheet,
  type ViewStyle,
  type StyleProp,
} from 'react-native';
import * as Haptics from 'expo-haptics';

export interface SegmentedControlOption {
  value: string;
  label: string;
  icon?: React.ReactNode;
}

export interface SegmentedControlProps {
  value: string;
  onChange: (value: string) => void;
  options: SegmentedControlOption[];
  size?: 'sm' | 'md';
  fullWidth?: boolean;
  disabled?: boolean;
  style?: StyleProp<ViewStyle>;
  testID?: string;
}

export function SegmentedControl({
  value,
  onChange,
  options,
  size = 'md',
  fullWidth = false,
  disabled = false,
  style,
  testID,
}: SegmentedControlProps) {
  const handlePress = async (optionValue: string) => {
    if (disabled || optionValue === value) return;

    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    onChange(optionValue);
  };

  return (
    <View
      style={[
        styles.container,
        sizeStyles[size].container,
        fullWidth && styles.fullWidth,
        style,
      ]}
      testID={testID}
      accessibilityRole="tablist"
    >
      {options.map((option, index) => {
        const isSelected = option.value === value;
        const isFirst = index === 0;
        const isLast = index === options.length - 1;

        return (
          <Pressable
            key={option.value}
            testID={`segment-${option.value}`}
            onPress={() => handlePress(option.value)}
            disabled={disabled}
            accessibilityRole="tab"
            accessibilityState={{ selected: isSelected, disabled }}
            style={({ pressed }) => [
              styles.segment,
              sizeStyles[size].segment,
              fullWidth && styles.segmentFullWidth,
              isFirst && styles.firstSegment,
              isLast && styles.lastSegment,
              isSelected && styles.selectedSegment,
              pressed && !disabled && styles.pressedSegment,
              disabled && styles.disabledSegment,
            ]}
          >
            {option.icon && (
              <View style={styles.iconContainer}>{option.icon}</View>
            )}
            <Text
              style={[
                styles.label,
                sizeStyles[size].label,
                isSelected && styles.selectedLabel,
                disabled && styles.disabledLabel,
              ]}
            >
              {option.label}
            </Text>
          </Pressable>
        );
      })}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    backgroundColor: '#F1F5F9', // slate-100
    borderRadius: 8,
    padding: 2,
  },
  fullWidth: {
    alignSelf: 'stretch',
  },
  segment: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: 6,
    gap: 4,
  },
  segmentFullWidth: {
    flex: 1,
  },
  firstSegment: {
    // Additional styling for first segment if needed
  },
  lastSegment: {
    // Additional styling for last segment if needed
  },
  selectedSegment: {
    backgroundColor: '#FFFFFF',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  pressedSegment: {
    opacity: 0.7,
  },
  disabledSegment: {
    opacity: 0.5,
  },
  iconContainer: {
    flexShrink: 0,
  },
  label: {
    fontWeight: '500',
    color: '#64748B', // slate-500
  },
  selectedLabel: {
    color: '#0D7C7A', // teal-700 (Klard primary)
  },
  disabledLabel: {
    color: '#94A3B8', // slate-400
  },
});

const sizeStyles = {
  sm: StyleSheet.create({
    container: {
      height: 32,
    },
    segment: {
      paddingHorizontal: 8,
      paddingVertical: 4,
    },
    label: {
      fontSize: 13,
    },
  }),
  md: StyleSheet.create({
    container: {
      height: 40,
    },
    segment: {
      paddingHorizontal: 12,
      paddingVertical: 6,
    },
    label: {
      fontSize: 14,
    },
  }),
};
```

**Step 2: Export from index.ts**

Add to `klard-mobile/src/components/ui/index.ts`:

```typescript
export {
  SegmentedControl,
  type SegmentedControlProps,
  type SegmentedControlOption,
} from './SegmentedControl';
```

**Step 3: Run tests to verify they pass**

Run: `pnpm --filter klard-mobile test src/__tests__/components/ui/SegmentedControl.test.tsx --run`
Expected: PASS (all tests green)

**Step 4: Type check**

Run: `pnpm --filter klard-mobile exec tsc --noEmit`
Expected: No errors

**Step 5: Commit**

```bash
git add klard-mobile/src/components/ui/SegmentedControl.tsx klard-mobile/src/components/ui/index.ts klard-mobile/src/__tests__/components/ui/SegmentedControl.test.tsx
git commit -m "feat(mobile): add SegmentedControl component with TDD"
```

---

## Task 5: Update Component Specification

**Files:**
- Modify: `docs/screens/batch/Klard_Component_Specifications.md`

**Step 1: Replace IN-PROGRESS with DONE marker**

Change:
```markdown
<!-- COMPONENT:START:2.5-segmented-control -->
<!-- IN-PROGRESS:2.5-segmented-control -->
```

To:
```markdown
<!-- COMPONENT:START:2.5-segmented-control -->
<!-- DONE:2.5-segmented-control -->
```

**Step 2: Commit**

```bash
git add docs/screens/batch/Klard_Component_Specifications.md
git commit -m "docs: mark 2.5-segmented-control component as done"
```

---

## Verification Checklist

Before marking complete, verify:

- [ ] Web component renders without errors
- [ ] Mobile component renders without errors
- [ ] All props implemented and typed correctly
- [ ] Selection state works correctly on both platforms
- [ ] Size variants (sm, md) work correctly
- [ ] fullWidth prop works correctly
- [ ] Icon support works correctly
- [ ] Disabled state works correctly
- [ ] Haptic feedback triggers on mobile
- [ ] Accessibility attributes present (role="tablist", role="tab")
- [ ] TypeScript passes: `pnpm --filter klard-web exec tsc --noEmit`
- [ ] TypeScript passes: `pnpm --filter klard-mobile exec tsc --noEmit`
- [ ] All web tests pass: `pnpm --filter klard-web test src/__tests__/components/ui/segmented-control.test.tsx --run`
- [ ] All mobile tests pass: `pnpm --filter klard-mobile test src/__tests__/components/ui/SegmentedControl.test.tsx --run`
- [ ] Components exported from index.ts
- [ ] Spec marker updated to DONE

---

## Summary

| Task | Description | Platform |
|------|-------------|----------|
| 1 | Write Web component tests | Web |
| 2 | Implement Web component | Web |
| 3 | Write Mobile component tests | Mobile |
| 4 | Implement Mobile component | Mobile |
| 5 | Update spec to DONE | Docs |

**Total Tasks:** 5
**Estimated Subtasks:** ~25 individual steps