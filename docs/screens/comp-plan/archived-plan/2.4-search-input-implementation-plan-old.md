# 2.4 SearchInput Component Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a production-ready SearchInput component for both Web (Next.js + shadcn/ui) and Mobile (React Native + Expo) platforms with debounced search, loading state, and full TDD coverage.

**Architecture:** Web wraps shadcn/ui Input with search-specific affordances (search icon, clear button, loading spinner, debounced callback). Mobile uses React Native TextInput with Ionicons and custom debounce implementation. Both support controlled value, immediate onChange, and debounced onSearch.

**Tech Stack:**
- Web: Next.js 16, React 19, TypeScript strict, shadcn/ui Input, lucide-react, usehooks-ts (useDebounceCallback), Tailwind CSS 4
- Mobile: React Native, Expo SDK 54, TypeScript strict, @expo/vector-icons (Ionicons), ActivityIndicator

---

## Pre-Implementation Checklist

Before starting, verify these skills are loaded:
- [ ] `superpowers:test-driven-development` - TDD workflow
- [ ] `superpowers:testing-anti-patterns` - Avoid common test mistakes
- [ ] `solid-design-principles` - SOLID compliance

---

## Component Specification

### Props Interface

```typescript
// Web
interface SearchInputProps
  extends Omit<React.InputHTMLAttributes<HTMLInputElement>, 'onChange' | 'type'> {
  value: string;
  onChange: (value: string) => void;
  onSearch?: (value: string) => void;
  placeholder?: string;
  loading?: boolean;
  debounceMs?: number;
}

// Mobile
interface SearchInputProps extends Omit<TextInputProps, 'onChangeText'> {
  value: string;
  onChangeText: (value: string) => void;
  onSearch?: (value: string) => void;
  placeholder?: string;
  loading?: boolean;
  debounceMs?: number;
  containerStyle?: StyleProp<ViewStyle>;
}
```

### Visual States

| State | Description |
|-------|-------------|
| Empty | Search icon visible, no clear button |
| With Value | Search icon + clear button visible |
| Loading | Search icon + loading spinner (no clear button) |
| Disabled | Reduced opacity, non-interactive |

### Color Tokens (Klard Design System)

| Element | Light Mode | Dark Mode |
|---------|------------|-----------|
| Icon | #94A3B8 (slate-400) | #64748B (slate-500) |
| Border | #CBD5E1 (slate-300) | #334155 (slate-700) |
| Border Focus | #0D7C7A (primary) | #15B5B0 (primary) |
| Placeholder | #94A3B8 | #64748B |

---

## SOLID Compliance

| Principle | Implementation |
|-----------|----------------|
| **SRP** | SearchInput only handles search input UI - no business logic |
| **OCP** | Extensible via className/style props, no modification needed |
| **LSP** | Handles all standard input props via spread |
| **ISP** | Minimal interface with only necessary props |
| **DIP** | Web depends on Input abstraction, Mobile depends on TextInput |

---

## Dependencies

### Web
- `usehooks-ts` - useDebounceCallback hook (needs installation)
- `lucide-react` - Search, X, Loader2 icons (already installed)
- `@/components/ui/input` - Base input component (already exists)
- `@/lib/utils` - cn utility (already exists)

### Mobile
- `@expo/vector-icons` - Ionicons (already installed)
- `react-native` - ActivityIndicator (built-in)
- No additional dependencies needed

---

# PART 1: WEB IMPLEMENTATION

## Task 1: Install usehooks-ts

**Files:**
- Modify: `klard-web/package.json`

**Step 1: Run pnpm to add usehooks-ts**

```bash
cd /Users/drcraig/Desktop/PersonalProjects/klard-apps
pnpm --filter klard-web add usehooks-ts
```

Expected: Package added to dependencies

**Step 2: Verify installation**

```bash
pnpm --filter klard-web exec tsc --noEmit
```

Expected: No TypeScript errors

---

## Task 2: Write Failing Tests for SearchInput Rendering

**Files:**
- Create: `klard-web/src/__tests__/components/ui/search-input.test.tsx`

**Step 1: Create test file with rendering tests**

```tsx
/**
 * Tests for SearchInput Component
 *
 * TDD: Write failing tests first, then implement to pass.
 * Tests verify: rendering, search icon, placeholder, clear button, loading, debounce
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { SearchInput } from '@/components/ui/search-input';

describe('SearchInput', () => {
  beforeEach(() => {
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  describe('Rendering', () => {
    it('should render with search icon', () => {
      render(<SearchInput value="" onChange={() => {}} />);

      const searchIcon = document.querySelector('[data-slot="search-icon"]');
      expect(searchIcon).toBeTruthy();
    });

    it('should render with data-slot attribute', () => {
      const { container } = render(<SearchInput value="" onChange={() => {}} />);

      const wrapper = container.querySelector('[data-slot="search-input"]');
      expect(wrapper).toBeTruthy();
    });

    it('should render with default placeholder', () => {
      render(<SearchInput value="" onChange={() => {}} />);

      expect(screen.getByPlaceholderText('Search...')).toBeTruthy();
    });

    it('should render with custom placeholder', () => {
      render(<SearchInput value="" onChange={() => {}} placeholder="Find subscriptions" />);

      expect(screen.getByPlaceholderText('Find subscriptions')).toBeTruthy();
    });

    it('should render as searchbox role', () => {
      render(<SearchInput value="" onChange={() => {}} />);

      expect(screen.getByRole('searchbox')).toBeTruthy();
    });
  });
});
```

**Step 2: Run tests to verify they fail**

```bash
cd /Users/drcraig/Desktop/PersonalProjects/klard-apps
pnpm --filter klard-web test src/__tests__/components/ui/search-input.test.tsx --run
```

Expected: FAIL - SearchInput component doesn't exist

---

## Task 3: Write Failing Tests for Clear Button

**Files:**
- Modify: `klard-web/src/__tests__/components/ui/search-input.test.tsx`

**Step 1: Add clear button tests**

```tsx
  describe('Clear Button', () => {
    it('should show clear button when value is present', () => {
      render(<SearchInput value="test" onChange={() => {}} />);

      expect(screen.getByLabelText('Clear search')).toBeTruthy();
    });

    it('should not show clear button when value is empty', () => {
      render(<SearchInput value="" onChange={() => {}} />);

      expect(screen.queryByLabelText('Clear search')).toBeNull();
    });

    it('should call onChange with empty string when clear is clicked', () => {
      const handleChange = vi.fn();
      render(<SearchInput value="test" onChange={handleChange} />);

      fireEvent.click(screen.getByLabelText('Clear search'));

      expect(handleChange).toHaveBeenCalledWith('');
    });

    it('should call onSearch with empty string when clear is clicked', () => {
      const handleSearch = vi.fn();
      render(<SearchInput value="test" onChange={() => {}} onSearch={handleSearch} />);

      fireEvent.click(screen.getByLabelText('Clear search'));

      expect(handleSearch).toHaveBeenCalledWith('');
    });
  });
```

**Step 2: Run tests to verify they fail**

```bash
pnpm --filter klard-web test src/__tests__/components/ui/search-input.test.tsx --run
```

Expected: FAIL - Clear button not implemented

---

## Task 4: Write Failing Tests for Loading State and Debounce

**Files:**
- Modify: `klard-web/src/__tests__/components/ui/search-input.test.tsx`

**Step 1: Add loading and debounce tests**

```tsx
  describe('Loading State', () => {
    it('should show loading spinner when loading is true', () => {
      render(<SearchInput value="test" onChange={() => {}} loading />);

      const spinner = document.querySelector('[data-slot="loading-spinner"]');
      expect(spinner).toBeTruthy();
    });

    it('should hide clear button when loading', () => {
      render(<SearchInput value="test" onChange={() => {}} loading />);

      expect(screen.queryByLabelText('Clear search')).toBeNull();
    });

    it('should not show spinner when not loading', () => {
      render(<SearchInput value="test" onChange={() => {}} loading={false} />);

      const spinner = document.querySelector('[data-slot="loading-spinner"]');
      expect(spinner).toBeNull();
    });
  });

  describe('Value and Change Handling', () => {
    it('should display controlled value', () => {
      render(<SearchInput value="test value" onChange={() => {}} />);

      const input = screen.getByRole('searchbox');
      expect(input).toHaveValue('test value');
    });

    it('should call onChange when typing', () => {
      const handleChange = vi.fn();
      render(<SearchInput value="" onChange={handleChange} />);

      const input = screen.getByRole('searchbox');
      fireEvent.change(input, { target: { value: 'new value' } });

      expect(handleChange).toHaveBeenCalledWith('new value');
    });
  });

  describe('Debounced Search', () => {
    it('should call onSearch after debounce delay', () => {
      const handleSearch = vi.fn();
      render(
        <SearchInput
          value=""
          onChange={() => {}}
          onSearch={handleSearch}
          debounceMs={300}
        />
      );

      const input = screen.getByRole('searchbox');
      fireEvent.change(input, { target: { value: 'test' } });

      expect(handleSearch).not.toHaveBeenCalled();

      vi.advanceTimersByTime(300);

      expect(handleSearch).toHaveBeenCalledWith('test');
    });

    it('should use default debounce of 300ms', () => {
      const handleSearch = vi.fn();
      render(<SearchInput value="" onChange={() => {}} onSearch={handleSearch} />);

      const input = screen.getByRole('searchbox');
      fireEvent.change(input, { target: { value: 'test' } });

      vi.advanceTimersByTime(299);
      expect(handleSearch).not.toHaveBeenCalled();

      vi.advanceTimersByTime(1);
      expect(handleSearch).toHaveBeenCalledWith('test');
    });

    it('should debounce multiple rapid inputs', () => {
      const handleSearch = vi.fn();
      render(
        <SearchInput
          value=""
          onChange={() => {}}
          onSearch={handleSearch}
          debounceMs={300}
        />
      );

      const input = screen.getByRole('searchbox');

      fireEvent.change(input, { target: { value: 't' } });
      vi.advanceTimersByTime(100);

      fireEvent.change(input, { target: { value: 'te' } });
      vi.advanceTimersByTime(100);

      fireEvent.change(input, { target: { value: 'tes' } });
      vi.advanceTimersByTime(100);

      fireEvent.change(input, { target: { value: 'test' } });
      vi.advanceTimersByTime(300);

      expect(handleSearch).toHaveBeenCalledTimes(1);
      expect(handleSearch).toHaveBeenCalledWith('test');
    });
  });

  describe('Disabled State', () => {
    it('should be disabled when disabled prop is true', () => {
      render(<SearchInput value="" onChange={() => {}} disabled />);

      const input = screen.getByRole('searchbox');
      expect(input).toBeDisabled();
    });

    it('should disable clear button when input is disabled', () => {
      render(<SearchInput value="test" onChange={() => {}} disabled />);

      const clearButton = screen.getByLabelText('Clear search');
      expect(clearButton).toBeDisabled();
    });
  });

  describe('Custom className', () => {
    it('should merge custom className', () => {
      const { container } = render(
        <SearchInput value="" onChange={() => {}} className="custom-class" />
      );

      const wrapper = container.querySelector('[data-slot="search-input"]');
      expect(wrapper?.className).toContain('custom-class');
    });
  });
```

**Step 2: Run all tests to verify they fail**

```bash
pnpm --filter klard-web test src/__tests__/components/ui/search-input.test.tsx --run
```

Expected: Multiple FAIL

---

## Task 5: Implement SearchInput Component

**Files:**
- Create: `klard-web/src/components/ui/search-input.tsx`

**Step 1: Create the SearchInput component**

```tsx
'use client';

import { forwardRef, useCallback } from 'react';
import { Search, X, Loader2 } from 'lucide-react';
import { useDebounceCallback } from 'usehooks-ts';
import { cn } from '@/lib/utils';
import { Input } from '@/components/ui/input';

export interface SearchInputProps
  extends Omit<React.InputHTMLAttributes<HTMLInputElement>, 'onChange' | 'type'> {
  /** Current search value (controlled) */
  value: string;
  /** Called immediately when input changes */
  onChange: (value: string) => void;
  /** Called after debounce delay with search term */
  onSearch?: (value: string) => void;
  /** Placeholder text */
  placeholder?: string;
  /** Show loading spinner instead of clear button */
  loading?: boolean;
  /** Debounce delay in milliseconds (default: 300) */
  debounceMs?: number;
}

export const SearchInput = forwardRef<HTMLInputElement, SearchInputProps>(
  function SearchInput(
    {
      value,
      onChange,
      onSearch,
      placeholder = 'Search...',
      loading = false,
      debounceMs = 300,
      disabled,
      className,
      ...props
    },
    ref
  ) {
    const debouncedSearch = useDebounceCallback(
      (searchValue: string) => {
        onSearch?.(searchValue);
      },
      debounceMs
    );

    const handleChange = useCallback(
      (e: React.ChangeEvent<HTMLInputElement>) => {
        const newValue = e.target.value;
        onChange(newValue);
        debouncedSearch(newValue);
      },
      [onChange, debouncedSearch]
    );

    const handleClear = useCallback(() => {
      onChange('');
      onSearch?.('');
      debouncedSearch.cancel();
    }, [onChange, onSearch, debouncedSearch]);

    const showClearButton = !loading && value.length > 0;

    return (
      <div data-slot="search-input" className={cn('relative', className)}>
        {/* Search icon */}
        <div
          data-slot="search-icon"
          className="absolute left-3 top-1/2 -translate-y-1/2 text-slate-400 dark:text-slate-500 pointer-events-none"
        >
          <Search className="h-4 w-4" />
        </div>

        {/* Input */}
        <Input
          ref={ref}
          type="search"
          value={value}
          onChange={handleChange}
          placeholder={placeholder}
          disabled={disabled}
          className={cn(
            'pl-10',
            (loading || showClearButton) && 'pr-10'
          )}
          {...props}
        />

        {/* Loading spinner */}
        {loading && (
          <div
            data-slot="loading-spinner"
            className="absolute right-3 top-1/2 -translate-y-1/2 text-slate-400 dark:text-slate-500"
          >
            <Loader2 className="h-4 w-4 animate-spin" />
          </div>
        )}

        {/* Clear button */}
        {showClearButton && (
          <button
            type="button"
            onClick={handleClear}
            disabled={disabled}
            className={cn(
              'absolute right-3 top-1/2 -translate-y-1/2',
              'text-slate-400 hover:text-slate-600 dark:text-slate-500 dark:hover:text-slate-300',
              'transition-colors p-1 rounded',
              'focus:outline-none focus:ring-2 focus:ring-primary/30',
              disabled && 'pointer-events-none opacity-50'
            )}
            aria-label="Clear search"
          >
            <X className="h-4 w-4" />
          </button>
        )}
      </div>
    );
  }
);
```

**Step 2: Run tests to verify they pass**

```bash
pnpm --filter klard-web test src/__tests__/components/ui/search-input.test.tsx --run
```

Expected: All tests PASS

---

## Task 6: Export SearchInput from Index

**Files:**
- Modify: `klard-web/src/components/ui/index.ts`

**Step 1: Add SearchInput export**

Add this line to the exports:

```typescript
export { SearchInput, type SearchInputProps } from './search-input';
```

**Step 2: Verify TypeScript compiles**

```bash
pnpm --filter klard-web exec tsc --noEmit
```

Expected: No TypeScript errors

**Step 3: Commit Web implementation**

```bash
git add klard-web/src/components/ui/search-input.tsx klard-web/src/components/ui/index.ts klard-web/src/__tests__/components/ui/search-input.test.tsx klard-web/package.json pnpm-lock.yaml
git commit -m "feat(web): add SearchInput component with TDD

- Add SearchInput component with debounced search
- Support loading state and clear button
- Install usehooks-ts for debounce utilities
- Comprehensive test coverage"
```

---

# PART 2: MOBILE IMPLEMENTATION

## Task 7: Write Failing Tests for Mobile SearchInput Rendering

**Files:**
- Create: `klard-mobile/src/__tests__/components/ui/SearchInput.test.tsx`

**Step 1: Create test file with rendering tests**

```tsx
/**
 * Tests for SearchInput Component (Mobile)
 *
 * TDD: Write failing tests first, then implement to pass.
 */

import React from 'react';
import { render, fireEvent, act } from '@testing-library/react-native';
import { SearchInput } from '@/components/ui/SearchInput';

jest.useFakeTimers();

describe('SearchInput', () => {
  afterEach(() => {
    jest.clearAllTimers();
  });

  describe('Rendering', () => {
    it('should render with search icon', () => {
      const { getByTestId } = render(
        <SearchInput value="" onChangeText={() => {}} />
      );

      expect(getByTestId('search-icon')).toBeTruthy();
    });

    it('should render search input container', () => {
      const { getByTestId } = render(
        <SearchInput value="" onChangeText={() => {}} />
      );

      expect(getByTestId('search-input-container')).toBeTruthy();
    });

    it('should render with default placeholder', () => {
      const { getByPlaceholderText } = render(
        <SearchInput value="" onChangeText={() => {}} />
      );

      expect(getByPlaceholderText('Search...')).toBeTruthy();
    });

    it('should render with custom placeholder', () => {
      const { getByPlaceholderText } = render(
        <SearchInput value="" onChangeText={() => {}} placeholder="Find subscriptions" />
      );

      expect(getByPlaceholderText('Find subscriptions')).toBeTruthy();
    });

    it('should render with search return key type', () => {
      const { getByTestId } = render(
        <SearchInput value="" onChangeText={() => {}} />
      );

      const input = getByTestId('search-input');
      expect(input.props.returnKeyType).toBe('search');
    });
  });
});
```

**Step 2: Run tests to verify they fail**

```bash
cd /Users/drcraig/Desktop/PersonalProjects/klard-apps
pnpm --filter klard-mobile test src/__tests__/components/ui/SearchInput.test.tsx --run
```

Expected: FAIL - SearchInput component doesn't exist

---

## Task 8: Write Failing Tests for Mobile Clear Button

**Files:**
- Modify: `klard-mobile/src/__tests__/components/ui/SearchInput.test.tsx`

**Step 1: Add clear button tests**

```tsx
  describe('Clear Button', () => {
    it('should show clear button when value is present', () => {
      const { getByLabelText } = render(
        <SearchInput value="test" onChangeText={() => {}} />
      );

      expect(getByLabelText('Clear search')).toBeTruthy();
    });

    it('should not show clear button when value is empty', () => {
      const { queryByLabelText } = render(
        <SearchInput value="" onChangeText={() => {}} />
      );

      expect(queryByLabelText('Clear search')).toBeNull();
    });

    it('should call onChangeText with empty string when clear is pressed', () => {
      const handleChange = jest.fn();
      const { getByLabelText } = render(
        <SearchInput value="test" onChangeText={handleChange} />
      );

      fireEvent.press(getByLabelText('Clear search'));

      expect(handleChange).toHaveBeenCalledWith('');
    });

    it('should call onSearch with empty string when clear is pressed', () => {
      const handleSearch = jest.fn();
      const { getByLabelText } = render(
        <SearchInput value="test" onChangeText={() => {}} onSearch={handleSearch} />
      );

      fireEvent.press(getByLabelText('Clear search'));

      expect(handleSearch).toHaveBeenCalledWith('');
    });
  });
```

**Step 2: Run tests to verify they fail**

```bash
pnpm --filter klard-mobile test src/__tests__/components/ui/SearchInput.test.tsx --run
```

Expected: FAIL - Clear button not implemented

---

## Task 9: Write Failing Tests for Mobile Loading and Debounce

**Files:**
- Modify: `klard-mobile/src/__tests__/components/ui/SearchInput.test.tsx`

**Step 1: Add loading and debounce tests**

```tsx
  describe('Loading State', () => {
    it('should show loading indicator when loading is true', () => {
      const { getByTestId } = render(
        <SearchInput value="test" onChangeText={() => {}} loading />
      );

      expect(getByTestId('loading-indicator')).toBeTruthy();
    });

    it('should hide clear button when loading', () => {
      const { queryByLabelText } = render(
        <SearchInput value="test" onChangeText={() => {}} loading />
      );

      expect(queryByLabelText('Clear search')).toBeNull();
    });

    it('should not show loading indicator when not loading', () => {
      const { queryByTestId } = render(
        <SearchInput value="test" onChangeText={() => {}} loading={false} />
      );

      expect(queryByTestId('loading-indicator')).toBeNull();
    });
  });

  describe('Value and Change Handling', () => {
    it('should display controlled value', () => {
      const { getByTestId } = render(
        <SearchInput value="test value" onChangeText={() => {}} />
      );

      const input = getByTestId('search-input');
      expect(input.props.value).toBe('test value');
    });

    it('should call onChangeText when typing', () => {
      const handleChange = jest.fn();
      const { getByTestId } = render(
        <SearchInput value="" onChangeText={handleChange} />
      );

      fireEvent.changeText(getByTestId('search-input'), 'new value');

      expect(handleChange).toHaveBeenCalledWith('new value');
    });
  });

  describe('Debounced Search', () => {
    it('should call onSearch after debounce delay', () => {
      const handleSearch = jest.fn();
      const { getByTestId } = render(
        <SearchInput
          value=""
          onChangeText={() => {}}
          onSearch={handleSearch}
          debounceMs={300}
        />
      );

      fireEvent.changeText(getByTestId('search-input'), 'test');

      expect(handleSearch).not.toHaveBeenCalled();

      act(() => {
        jest.advanceTimersByTime(300);
      });

      expect(handleSearch).toHaveBeenCalledWith('test');
    });

    it('should use default debounce of 300ms', () => {
      const handleSearch = jest.fn();
      const { getByTestId } = render(
        <SearchInput value="" onChangeText={() => {}} onSearch={handleSearch} />
      );

      fireEvent.changeText(getByTestId('search-input'), 'test');

      act(() => {
        jest.advanceTimersByTime(299);
      });
      expect(handleSearch).not.toHaveBeenCalled();

      act(() => {
        jest.advanceTimersByTime(1);
      });
      expect(handleSearch).toHaveBeenCalledWith('test');
    });
  });

  describe('Submit Handling', () => {
    it('should call onSearch immediately on submit', () => {
      const handleSearch = jest.fn();
      const { getByTestId } = render(
        <SearchInput value="test" onChangeText={() => {}} onSearch={handleSearch} />
      );

      fireEvent(getByTestId('search-input'), 'submitEditing');

      expect(handleSearch).toHaveBeenCalledWith('test');
    });
  });

  describe('Disabled State', () => {
    it('should not be editable when disabled', () => {
      const { getByTestId } = render(
        <SearchInput value="" onChangeText={() => {}} editable={false} />
      );

      const input = getByTestId('search-input');
      expect(input.props.editable).toBe(false);
    });
  });
```

**Step 2: Run all tests to verify they fail**

```bash
pnpm --filter klard-mobile test src/__tests__/components/ui/SearchInput.test.tsx --run
```

Expected: Multiple FAIL

---

## Task 10: Implement Mobile SearchInput Component

**Files:**
- Create: `klard-mobile/src/components/ui/SearchInput.tsx`

**Step 1: Create the SearchInput component**

```tsx
import React, { useState, useCallback, useRef, useEffect } from 'react';
import {
  View,
  TextInput,
  Pressable,
  ActivityIndicator,
  StyleSheet,
  type TextInputProps,
  type StyleProp,
  type ViewStyle,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';

export interface SearchInputProps extends Omit<TextInputProps, 'onChangeText'> {
  /** Current search value (controlled) */
  value: string;
  /** Called immediately when input changes */
  onChangeText: (value: string) => void;
  /** Called after debounce delay with search term */
  onSearch?: (value: string) => void;
  /** Placeholder text */
  placeholder?: string;
  /** Show loading indicator instead of clear button */
  loading?: boolean;
  /** Debounce delay in milliseconds (default: 300) */
  debounceMs?: number;
  /** Container style override */
  containerStyle?: StyleProp<ViewStyle>;
}

export function SearchInput({
  value,
  onChangeText,
  onSearch,
  placeholder = 'Search...',
  loading = false,
  debounceMs = 300,
  editable = true,
  containerStyle,
  ...props
}: SearchInputProps) {
  const [isFocused, setIsFocused] = useState(false);
  const debounceTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  useEffect(() => {
    return () => {
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }
    };
  }, []);

  const debouncedSearch = useCallback(
    (searchValue: string) => {
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }

      debounceTimerRef.current = setTimeout(() => {
        onSearch?.(searchValue);
      }, debounceMs);
    },
    [onSearch, debounceMs]
  );

  const handleChangeText = useCallback(
    (text: string) => {
      onChangeText(text);
      debouncedSearch(text);
    },
    [onChangeText, debouncedSearch]
  );

  const handleClear = useCallback(() => {
    if (debounceTimerRef.current) {
      clearTimeout(debounceTimerRef.current);
    }
    onChangeText('');
    onSearch?.('');
  }, [onChangeText, onSearch]);

  const handleSubmitEditing = useCallback(() => {
    if (debounceTimerRef.current) {
      clearTimeout(debounceTimerRef.current);
    }
    onSearch?.(value);
  }, [onSearch, value]);

  const handleFocus = useCallback(() => {
    setIsFocused(true);
  }, []);

  const handleBlur = useCallback(() => {
    setIsFocused(false);
  }, []);

  const showClearButton = !loading && value.length > 0;
  const disabled = !editable;

  return (
    <View
      testID="search-input-container"
      style={[
        styles.container,
        isFocused && styles.containerFocused,
        disabled && styles.containerDisabled,
        containerStyle,
      ]}
    >
      {/* Search icon */}
      <View style={styles.iconContainer} testID="search-icon">
        <Ionicons name="search" size={20} color={colors.icon} />
      </View>

      {/* TextInput */}
      <TextInput
        testID="search-input"
        value={value}
        onChangeText={handleChangeText}
        onFocus={handleFocus}
        onBlur={handleBlur}
        onSubmitEditing={handleSubmitEditing}
        placeholder={placeholder}
        placeholderTextColor={colors.placeholder}
        editable={editable}
        returnKeyType="search"
        autoCapitalize="none"
        autoCorrect={false}
        style={[
          styles.input,
          (loading || showClearButton) && styles.inputWithAction,
          disabled && styles.inputDisabled,
        ]}
        {...props}
      />

      {/* Loading indicator */}
      {loading && (
        <View style={styles.actionContainer} testID="loading-indicator">
          <ActivityIndicator size="small" color={colors.icon} />
        </View>
      )}

      {/* Clear button */}
      {showClearButton && (
        <Pressable
          onPress={handleClear}
          disabled={disabled}
          style={styles.actionContainer}
          accessibilityLabel="Clear search"
          accessibilityRole="button"
        >
          <Ionicons name="close-circle" size={20} color={colors.icon} />
        </Pressable>
      )}
    </View>
  );
}

const colors = {
  primary: '#0D7C7A',
  border: '#CBD5E1',
  borderFocused: '#0D7C7A',
  placeholder: '#94A3B8',
  icon: '#64748B',
  text: '#0F172A',
  background: '#FFFFFF',
  backgroundDisabled: '#F1F5F9',
};

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: colors.background,
    borderWidth: 1,
    borderColor: colors.border,
    borderRadius: 12,
    height: 48,
  },
  containerFocused: {
    borderWidth: 2,
    borderColor: colors.borderFocused,
  },
  containerDisabled: {
    backgroundColor: colors.backgroundDisabled,
    opacity: 0.7,
  },
  iconContainer: {
    paddingLeft: 12,
    paddingRight: 8,
  },
  input: {
    flex: 1,
    height: '100%',
    fontSize: 16,
    color: colors.text,
    paddingRight: 12,
  },
  inputWithAction: {
    paddingRight: 8,
  },
  inputDisabled: {
    color: colors.icon,
  },
  actionContainer: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    justifyContent: 'center',
    alignItems: 'center',
  },
});
```

**Step 2: Run tests to verify they pass**

```bash
pnpm --filter klard-mobile test src/__tests__/components/ui/SearchInput.test.tsx --run
```

Expected: All tests PASS

---

## Task 11: Export Mobile SearchInput from Index

**Files:**
- Modify: `klard-mobile/src/components/ui/index.ts`

**Step 1: Add SearchInput export**

Add this line to the exports:

```typescript
export { SearchInput, type SearchInputProps } from './SearchInput';
```

**Step 2: Verify TypeScript compiles**

```bash
pnpm --filter klard-mobile exec tsc --noEmit
```

Expected: No TypeScript errors

**Step 3: Commit Mobile implementation**

```bash
git add klard-mobile/src/components/ui/SearchInput.tsx klard-mobile/src/components/ui/index.ts klard-mobile/src/__tests__/components/ui/SearchInput.test.tsx
git commit -m "feat(mobile): add SearchInput component with TDD

- Add SearchInput component with debounced search
- Support loading state and clear button
- Submit on enter key
- Comprehensive test coverage"
```

---

# PART 3: VERIFICATION & COMPLETION

## Task 12: Run Full Test Suite

**Step 1: Run all web tests**

```bash
pnpm --filter klard-web test --run
```

Expected: All tests PASS

**Step 2: Run all mobile tests**

```bash
pnpm --filter klard-mobile test --run
```

Expected: All tests PASS

**Step 3: Run TypeScript check on both**

```bash
pnpm --filter klard-web exec tsc --noEmit && pnpm --filter klard-mobile exec tsc --noEmit
```

Expected: No TypeScript errors

---

## Task 13: Verification Checklist

Complete this checklist before marking component as DONE:

**Web SearchInput:**
- [ ] Component renders without errors
- [ ] Search icon visible
- [ ] Clear button shows when value present
- [ ] Clear button hidden when value empty
- [ ] Loading spinner shows when loading=true
- [ ] Clear button hidden when loading
- [ ] onChange called immediately on input
- [ ] onSearch called after debounce delay
- [ ] Debounce can be customized via debounceMs
- [ ] Disabled state works
- [ ] Custom className merges correctly
- [ ] TypeScript compiles with no errors
- [ ] All tests passing
- [ ] Exported from index.ts

**Mobile SearchInput:**
- [ ] Component renders without errors
- [ ] Search icon visible
- [ ] Clear button shows when value present
- [ ] Clear button hidden when value empty
- [ ] Loading indicator shows when loading=true
- [ ] Clear button hidden when loading
- [ ] onChangeText called immediately on input
- [ ] onSearch called after debounce delay
- [ ] onSearch called immediately on submit (enter key)
- [ ] Disabled state works
- [ ] TypeScript compiles with no errors
- [ ] All tests passing
- [ ] Exported from index.ts

---

## Task 14: Mark Component as DONE

**Files:**
- Modify: `docs/screens/batch/Klard_Component_Specifications.md`

**Step 1: Update spec marker**

Replace:
```
<!-- IN-PROGRESS:2.4-search-input -->
```

With:
```
<!-- DONE:2.4-search-input -->
```

**Step 2: Final commit**

```bash
git add docs/screens/batch/Klard_Component_Specifications.md
git commit -m "docs: mark 2.4-search-input component as DONE"
```

---

## Summary

| Task | Platform | Description |
|------|----------|-------------|
| 1 | Web | Install usehooks-ts |
| 2-4 | Web | Write failing tests (TDD RED phase) |
| 5 | Web | Implement SearchInput component (TDD GREEN phase) |
| 6 | Web | Export from index.ts |
| 7-9 | Mobile | Write failing tests (TDD RED phase) |
| 10 | Mobile | Implement SearchInput component (TDD GREEN phase) |
| 11 | Mobile | Export from index.ts |
| 12 | Both | Run full test suite |
| 13 | Both | Verification checklist |
| 14 | Docs | Mark component as DONE |

**Total Tasks:** 14
**Estimated Time:** 30-45 minutes

---

## File Structure

### Web
```
klard-web/src/
├── components/ui/
│   ├── search-input.tsx    # Klard component
│   └── index.ts            # Export added
└── __tests__/components/ui/
    └── search-input.test.tsx # Test file
```

### Mobile
```
klard-mobile/src/
├── components/ui/
│   ├── SearchInput.tsx     # Component
│   └── index.ts            # Export added
└── __tests__/components/ui/
    └── SearchInput.test.tsx # Test file
```

---

## Execution Options

**Plan complete and saved to `docs/screens/comp-plan/2.4-search-input-implementation-plan.md`.**

**Two execution options:**

1. **Subagent-Driven (this session)** - Dispatch fresh subagent per task, review between tasks, fast iteration

2. **Parallel Session (separate)** - Open new session with executing-plans, batch execution with checkpoints

**Which approach?**