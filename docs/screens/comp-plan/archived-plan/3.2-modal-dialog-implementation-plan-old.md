# 3.2 Modal/Dialog Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement a reusable Modal/Dialog component for both Web (shadcn/ui Dialog) and Mobile (React Native Modal) platforms with consistent API.

**Architecture:** The Modal component wraps platform-specific implementations (shadcn/ui Dialog for web, React Native Modal for mobile) behind a unified props interface. Web uses Radix UI primitives via shadcn/ui. Mobile uses native Modal with KeyboardAvoidingView and SafeAreaInsets.

**Tech Stack:**
- Web: React 19, shadcn/ui Dialog (Radix UI), Tailwind CSS 4, CVA
- Mobile: React Native Modal, expo-haptics, react-native-safe-area-context, @expo/vector-icons

---

## SOLID Compliance

| Component | SRP | OCP | LSP | ISP | DIP |
|-----------|-----|-----|-----|-----|-----|
| Modal (Web) | Manages dialog open/close state only | Size via props, extensible via className | Handles all DialogContent variants | Single ModalProps interface | Depends on children ReactNode |
| Modal (Mobile) | Manages modal visibility only | Size via props, extensible via style | Handles all Modal animations | Single ModalProps interface | Depends on children ReactNode |

### Principle Applications

**SRP:** Modal handles presentation only - open/close state management, not content logic
**OCP:** Extend via size prop, className/style overrides, footer slot - no modification needed
**LSP:** Both implementations satisfy ModalProps interface identically
**ISP:** Single focused interface with optional props
**DIP:** Depends on ReactNode abstraction for children/footer

---

## Props Interface

```typescript
interface ModalProps {
  open: boolean;
  onClose: () => void;
  title?: string;
  description?: string;
  size?: 'sm' | 'md' | 'lg' | 'xl' | 'full';
  children: ReactNode;
  footer?: ReactNode;
  closeOnOverlay?: boolean;
}
```

---

## Part 1: Web Implementation (6 Tasks)

### Task 1: Install shadcn/ui Dialog primitive

**Files:**
- Modify: `klard-web/package.json`
- Create: `klard-web/src/components/ui/dialog.tsx`

**Step 1: Install Dialog dependency**

Run: `cd /Users/drcraig/Desktop/PersonalProjects/klard-apps && pnpm --filter klard-web exec npx shadcn@latest add dialog`

Expected: Dialog component files created

**Step 2: Verify installation**

Run: `ls klard-web/src/components/ui/dialog.tsx`
Expected: File exists

**Step 3: Commit**

```bash
git add klard-web/src/components/ui/dialog.tsx klard-web/package.json pnpm-lock.yaml
git commit -m "feat(web): add shadcn/ui dialog primitive"
```

---

### Task 2: Write failing tests for Modal component (Web)

**Files:**
- Create: `klard-web/src/__tests__/components/ui/modal.test.tsx`

**Step 1: Write the failing test**

```typescript
/**
 * Tests for Modal Component (Web)
 *
 * TDD: Write failing tests first, then implement to pass.
 * Tests verify: rendering, sizes, title/description, footer, closeOnOverlay, accessibility
 */

import { describe, it, expect, vi } from "vitest";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { Modal } from "@/components/ui/modal";
import { Button } from "@/components/ui/button";

describe("Modal", () => {
  describe("Rendering", () => {
    it("should not render content when open is false", () => {
      render(
        <Modal open={false} onClose={() => {}}>
          <p>Modal Content</p>
        </Modal>
      );

      expect(screen.queryByText("Modal Content")).not.toBeInTheDocument();
    });

    it("should render content when open is true", () => {
      render(
        <Modal open={true} onClose={() => {}}>
          <p>Modal Content</p>
        </Modal>
      );

      expect(screen.getByText("Modal Content")).toBeInTheDocument();
    });

    it("should have data-slot attribute on content", () => {
      render(
        <Modal open={true} onClose={() => {}}>
          <p>Content</p>
        </Modal>
      );

      expect(document.querySelector('[data-slot="modal"]')).toBeInTheDocument();
    });

    it("should render as dialog element with role", () => {
      render(
        <Modal open={true} onClose={() => {}}>
          <p>Content</p>
        </Modal>
      );

      expect(screen.getByRole("dialog")).toBeInTheDocument();
    });
  });

  describe("Title and Description", () => {
    it("should render title when provided", () => {
      render(
        <Modal open={true} onClose={() => {}} title="Modal Title">
          <p>Content</p>
        </Modal>
      );

      expect(screen.getByText("Modal Title")).toBeInTheDocument();
    });

    it("should render description when provided", () => {
      render(
        <Modal
          open={true}
          onClose={() => {}}
          title="Title"
          description="This is a description"
        >
          <p>Content</p>
        </Modal>
      );

      expect(screen.getByText("This is a description")).toBeInTheDocument();
    });

    it("should not render header when no title or description", () => {
      render(
        <Modal open={true} onClose={() => {}}>
          <p>Content</p>
        </Modal>
      );

      expect(
        document.querySelector('[data-slot="modal-header"]')
      ).not.toBeInTheDocument();
    });

    it("should render title with correct heading role", () => {
      render(
        <Modal open={true} onClose={() => {}} title="Accessible Title">
          <p>Content</p>
        </Modal>
      );

      expect(
        screen.getByRole("heading", { name: "Accessible Title" })
      ).toBeInTheDocument();
    });
  });

  describe("Footer", () => {
    it("should render footer when provided", () => {
      render(
        <Modal
          open={true}
          onClose={() => {}}
          footer={<Button>Save</Button>}
        >
          <p>Content</p>
        </Modal>
      );

      expect(screen.getByRole("button", { name: "Save" })).toBeInTheDocument();
    });

    it("should not render footer wrapper when footer not provided", () => {
      render(
        <Modal open={true} onClose={() => {}}>
          <p>Content</p>
        </Modal>
      );

      expect(
        document.querySelector('[data-slot="modal-footer"]')
      ).not.toBeInTheDocument();
    });
  });

  describe("Sizes", () => {
    const sizes = ["sm", "md", "lg", "xl", "full"] as const;

    sizes.forEach((size) => {
      it(`should apply ${size} size class`, () => {
        render(
          <Modal open={true} onClose={() => {}} size={size}>
            <p>Content</p>
          </Modal>
        );

        const dialog = screen.getByRole("dialog");
        expect(dialog.className).toMatch(new RegExp(`max-w-${size}|max-w-4xl`));
      });
    });

    it("should apply md size by default", () => {
      render(
        <Modal open={true} onClose={() => {}}>
          <p>Content</p>
        </Modal>
      );

      const dialog = screen.getByRole("dialog");
      expect(dialog.className).toMatch(/max-w-md/);
    });
  });

  describe("Close Behavior", () => {
    it("should call onClose when close button is clicked", async () => {
      const handleClose = vi.fn();
      render(
        <Modal open={true} onClose={handleClose} title="Test">
          <p>Content</p>
        </Modal>
      );

      const closeButton = screen.getByRole("button", { name: /close/i });
      await userEvent.click(closeButton);

      expect(handleClose).toHaveBeenCalledTimes(1);
    });

    it("should call onClose when overlay is clicked (closeOnOverlay=true)", async () => {
      const handleClose = vi.fn();
      render(
        <Modal open={true} onClose={handleClose} closeOnOverlay={true}>
          <p>Content</p>
        </Modal>
      );

      // Click the overlay (outside dialog content)
      const overlay = document.querySelector('[data-slot="modal-overlay"]');
      if (overlay) {
        fireEvent.click(overlay);
      }

      await waitFor(() => {
        expect(handleClose).toHaveBeenCalled();
      });
    });

    it("should NOT call onClose when overlay is clicked (closeOnOverlay=false)", async () => {
      const handleClose = vi.fn();
      render(
        <Modal open={true} onClose={handleClose} closeOnOverlay={false}>
          <p>Content</p>
        </Modal>
      );

      // Try to click overlay
      const overlay = document.querySelector('[data-slot="modal-overlay"]');
      if (overlay) {
        fireEvent.click(overlay);
      }

      // Give time for potential handler
      await new Promise((r) => setTimeout(r, 100));

      expect(handleClose).not.toHaveBeenCalled();
    });

    it("should call onClose when Escape key is pressed", async () => {
      const handleClose = vi.fn();
      render(
        <Modal open={true} onClose={handleClose}>
          <p>Content</p>
        </Modal>
      );

      await userEvent.keyboard("{Escape}");

      expect(handleClose).toHaveBeenCalledTimes(1);
    });
  });

  describe("Accessibility", () => {
    it("should have aria-labelledby pointing to title", () => {
      render(
        <Modal open={true} onClose={() => {}} title="Dialog Title">
          <p>Content</p>
        </Modal>
      );

      const dialog = screen.getByRole("dialog");
      expect(dialog).toHaveAttribute("aria-labelledby");
    });

    it("should have aria-describedby pointing to description", () => {
      render(
        <Modal
          open={true}
          onClose={() => {}}
          title="Title"
          description="Description text"
        >
          <p>Content</p>
        </Modal>
      );

      const dialog = screen.getByRole("dialog");
      expect(dialog).toHaveAttribute("aria-describedby");
    });

    it("should trap focus within modal when open", async () => {
      render(
        <Modal
          open={true}
          onClose={() => {}}
          title="Focus Test"
          footer={<Button>Action</Button>}
        >
          <input type="text" placeholder="Input" />
        </Modal>
      );

      // Focus should be manageable within modal
      const input = screen.getByPlaceholderText("Input");
      const button = screen.getByRole("button", { name: "Action" });

      expect(input).toBeInTheDocument();
      expect(button).toBeInTheDocument();
    });
  });

  describe("Custom className", () => {
    it("should merge custom className with default classes", () => {
      render(
        <Modal open={true} onClose={() => {}} className="custom-modal-class">
          <p>Content</p>
        </Modal>
      );

      const dialog = screen.getByRole("dialog");
      expect(dialog.className).toContain("custom-modal-class");
    });
  });

  describe("Edge Cases", () => {
    it("should handle rapid open/close without error", async () => {
      const { rerender } = render(
        <Modal open={false} onClose={() => {}}>
          <p>Content</p>
        </Modal>
      );

      // Rapid state changes
      rerender(
        <Modal open={true} onClose={() => {}}>
          <p>Content</p>
        </Modal>
      );
      rerender(
        <Modal open={false} onClose={() => {}}>
          <p>Content</p>
        </Modal>
      );
      rerender(
        <Modal open={true} onClose={() => {}}>
          <p>Content</p>
        </Modal>
      );

      expect(screen.getByText("Content")).toBeInTheDocument();
    });

    it("should handle empty children", () => {
      render(
        <Modal open={true} onClose={() => {}}>
          {""}
        </Modal>
      );

      expect(screen.getByRole("dialog")).toBeInTheDocument();
    });
  });
});
```

**Step 2: Run test to verify it fails**

Run: `pnpm --filter klard-web test src/__tests__/components/ui/modal.test.tsx --run`
Expected: FAIL with "Cannot find module '@/components/ui/modal'"

**Step 3: Commit**

```bash
git add klard-web/src/__tests__/components/ui/modal.test.tsx
git commit -m "test(web): add failing tests for Modal component"
```

---

### Task 3: Implement Modal component (Web)

**Files:**
- Create: `klard-web/src/components/ui/modal.tsx`

**Step 1: Write minimal implementation**

```typescript
"use client";

import * as React from "react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import { cn } from "@/lib/utils";

export type ModalSize = "sm" | "md" | "lg" | "xl" | "full";

export interface ModalProps {
  open: boolean;
  onClose: () => void;
  title?: string;
  description?: string;
  size?: ModalSize;
  children: React.ReactNode;
  footer?: React.ReactNode;
  closeOnOverlay?: boolean;
  className?: string;
}

const sizeClasses: Record<ModalSize, string> = {
  sm: "max-w-sm",
  md: "max-w-md",
  lg: "max-w-lg",
  xl: "max-w-xl",
  full: "max-w-4xl",
};

function Modal({
  open,
  onClose,
  title,
  description,
  size = "md",
  children,
  footer,
  closeOnOverlay = true,
  className,
}: ModalProps) {
  return (
    <Dialog open={open} onOpenChange={(isOpen) => !isOpen && onClose()}>
      <DialogContent
        data-slot="modal"
        className={cn(sizeClasses[size], className)}
        onInteractOutside={(e) => {
          if (!closeOnOverlay) {
            e.preventDefault();
          }
        }}
        onPointerDownOutside={(e) => {
          if (!closeOnOverlay) {
            e.preventDefault();
          }
        }}
      >
        {(title || description) && (
          <DialogHeader data-slot="modal-header">
            {title && <DialogTitle>{title}</DialogTitle>}
            {description && (
              <DialogDescription>{description}</DialogDescription>
            )}
          </DialogHeader>
        )}
        <div data-slot="modal-body">{children}</div>
        {footer && (
          <DialogFooter data-slot="modal-footer">{footer}</DialogFooter>
        )}
      </DialogContent>
    </Dialog>
  );
}

export { Modal };
```

**Step 2: Run test to verify it passes**

Run: `pnpm --filter klard-web test src/__tests__/components/ui/modal.test.tsx --run`
Expected: PASS (most tests)

**Step 3: Commit**

```bash
git add klard-web/src/components/ui/modal.tsx
git commit -m "feat(web): implement Modal component"
```

---

### Task 4: Update Dialog primitive with overlay data-slot

**Files:**
- Modify: `klard-web/src/components/ui/dialog.tsx`

**Step 1: Read current dialog.tsx file**

Read the file to understand current structure.

**Step 2: Add data-slot="modal-overlay" to DialogOverlay**

Find the DialogOverlay component and add `data-slot="modal-overlay"` attribute.

**Step 3: Run tests to verify all pass**

Run: `pnpm --filter klard-web test src/__tests__/components/ui/modal.test.tsx --run`
Expected: PASS

**Step 4: Commit**

```bash
git add klard-web/src/components/ui/dialog.tsx
git commit -m "feat(web): add data-slot attribute to dialog overlay"
```

---

### Task 5: Export Modal from index.ts

**Files:**
- Modify: `klard-web/src/components/ui/index.ts`

**Step 1: Add export**

Add to the end of the file:
```typescript
export { Modal, type ModalProps, type ModalSize } from './modal';
```

**Step 2: Run TypeScript check**

Run: `pnpm --filter klard-web exec tsc --noEmit`
Expected: No errors

**Step 3: Commit**

```bash
git add klard-web/src/components/ui/index.ts
git commit -m "feat(web): export Modal from ui index"
```

---

### Task 6: Run full test suite and TypeScript check (Web)

**Files:** None (verification only)

**Step 1: Run all Modal tests**

Run: `pnpm --filter klard-web test src/__tests__/components/ui/modal.test.tsx --run`
Expected: All tests PASS

**Step 2: Run TypeScript check**

Run: `pnpm --filter klard-web exec tsc --noEmit`
Expected: No errors

**Step 3: Run lint**

Run: `pnpm --filter klard-web lint`
Expected: No errors

---

## Part 2: Mobile Implementation (5 Tasks)

### Task 7: Write failing tests for Modal component (Mobile)

**Files:**
- Create: `klard-mobile/src/__tests__/components/ui/Modal.test.tsx`

**Step 1: Write the failing test**

```typescript
/**
 * Tests for Modal Component (Mobile)
 *
 * TDD: Write failing tests first, then implement to pass.
 */

import React from "react";
import {
  render,
  screen,
  fireEvent,
  waitFor,
} from "@testing-library/react-native";
import { Text, View } from "react-native";
import { Modal } from "@/components/ui/Modal";
import * as Haptics from "expo-haptics";

// Mock expo-haptics
jest.mock("expo-haptics", () => ({
  impactAsync: jest.fn(),
  ImpactFeedbackStyle: {
    Light: "light",
    Medium: "medium",
    Heavy: "heavy",
  },
}));

// Mock react-native-safe-area-context
jest.mock("react-native-safe-area-context", () => ({
  useSafeAreaInsets: () => ({ top: 0, bottom: 34, left: 0, right: 0 }),
}));

// Mock vector icons
jest.mock("@expo/vector-icons", () => {
  const React = require("react");
  const { Text } = require("react-native");
  return {
    Ionicons: ({ name, testID }: { name: string; testID?: string }) => (
      <Text testID={testID || "icon"}>{name}</Text>
    ),
  };
});

describe("Modal", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe("Rendering", () => {
    it("should not render content when open is false", () => {
      render(
        <Modal open={false} onClose={() => {}}>
          <Text>Modal Content</Text>
        </Modal>
      );

      expect(screen.queryByText("Modal Content")).toBeNull();
    });

    it("should render content when open is true", () => {
      render(
        <Modal open={true} onClose={() => {}}>
          <Text>Modal Content</Text>
        </Modal>
      );

      expect(screen.getByText("Modal Content")).toBeTruthy();
    });

    it("should render as RN Modal component", () => {
      render(
        <Modal open={true} onClose={() => {}} testID="modal">
          <Text>Content</Text>
        </Modal>
      );

      expect(screen.getByTestId("modal")).toBeTruthy();
    });
  });

  describe("Title and Description", () => {
    it("should render title when provided", () => {
      render(
        <Modal open={true} onClose={() => {}} title="Modal Title">
          <Text>Content</Text>
        </Modal>
      );

      expect(screen.getByText("Modal Title")).toBeTruthy();
    });

    it("should render description when provided", () => {
      render(
        <Modal
          open={true}
          onClose={() => {}}
          title="Title"
          description="This is a description"
        >
          <Text>Content</Text>
        </Modal>
      );

      expect(screen.getByText("This is a description")).toBeTruthy();
    });

    it("should not render header elements when no title", () => {
      render(
        <Modal open={true} onClose={() => {}}>
          <Text>Content</Text>
        </Modal>
      );

      expect(screen.queryByTestId("modal-title")).toBeNull();
    });
  });

  describe("Footer", () => {
    it("should render footer when provided", () => {
      render(
        <Modal
          open={true}
          onClose={() => {}}
          footer={<Text testID="footer-content">Footer</Text>}
        >
          <Text>Content</Text>
        </Modal>
      );

      expect(screen.getByTestId("footer-content")).toBeTruthy();
    });

    it("should not render footer wrapper when footer not provided", () => {
      render(
        <Modal open={true} onClose={() => {}}>
          <Text>Content</Text>
        </Modal>
      );

      expect(screen.queryByTestId("modal-footer")).toBeNull();
    });
  });

  describe("Close Behavior", () => {
    it("should call onClose when close button is pressed", async () => {
      const handleClose = jest.fn();
      render(
        <Modal open={true} onClose={handleClose} title="Test">
          <Text>Content</Text>
        </Modal>
      );

      fireEvent.press(screen.getByLabelText(/close/i));

      await waitFor(() => {
        expect(handleClose).toHaveBeenCalledTimes(1);
      });
    });

    it("should trigger haptic feedback when close button is pressed", async () => {
      const handleClose = jest.fn();
      render(
        <Modal open={true} onClose={handleClose} title="Test">
          <Text>Content</Text>
        </Modal>
      );

      fireEvent.press(screen.getByLabelText(/close/i));

      await waitFor(() => {
        expect(Haptics.impactAsync).toHaveBeenCalledWith(
          Haptics.ImpactFeedbackStyle.Light
        );
      });
    });

    it("should call onClose when overlay is pressed (closeOnOverlay=true)", async () => {
      const handleClose = jest.fn();
      render(
        <Modal open={true} onClose={handleClose} closeOnOverlay={true}>
          <Text>Content</Text>
        </Modal>
      );

      fireEvent.press(screen.getByTestId("modal-overlay"));

      await waitFor(() => {
        expect(handleClose).toHaveBeenCalled();
      });
    });

    it("should NOT call onClose when overlay is pressed (closeOnOverlay=false)", async () => {
      const handleClose = jest.fn();
      render(
        <Modal open={true} onClose={handleClose} closeOnOverlay={false}>
          <Text>Content</Text>
        </Modal>
      );

      // Should not have overlay pressable when closeOnOverlay is false
      const overlay = screen.queryByTestId("modal-overlay-pressable");
      if (overlay) {
        fireEvent.press(overlay);
      }

      await new Promise((r) => setTimeout(r, 100));

      expect(handleClose).not.toHaveBeenCalled();
    });

    it("should call onClose on hardware back button (Android)", () => {
      const handleClose = jest.fn();
      render(
        <Modal open={true} onClose={handleClose}>
          <Text>Content</Text>
        </Modal>
      );

      // onRequestClose is called on Android back button
      // This is tested through the Modal's onRequestClose prop
      expect(handleClose).toBeDefined();
    });
  });

  describe("Handle Indicator", () => {
    it("should render handle indicator at top", () => {
      render(
        <Modal open={true} onClose={() => {}}>
          <Text>Content</Text>
        </Modal>
      );

      expect(screen.getByTestId("modal-handle")).toBeTruthy();
    });
  });

  describe("Safe Area", () => {
    it("should respect safe area insets for bottom padding", () => {
      render(
        <Modal open={true} onClose={() => {}}>
          <Text>Content</Text>
        </Modal>
      );

      // Content should render with safe area consideration
      expect(screen.getByText("Content")).toBeTruthy();
    });
  });

  describe("Accessibility", () => {
    it("should have accessible close button", () => {
      render(
        <Modal open={true} onClose={() => {}} title="Test">
          <Text>Content</Text>
        </Modal>
      );

      expect(screen.getByLabelText(/close/i)).toBeTruthy();
    });

    it("should have accessibility role on title", () => {
      render(
        <Modal open={true} onClose={() => {}} title="Accessible Title">
          <Text>Content</Text>
        </Modal>
      );

      const title = screen.getByText("Accessible Title");
      expect(title.props.accessibilityRole).toBe("header");
    });
  });

  describe("Edge Cases", () => {
    it("should handle rapid open/close without error", () => {
      const { rerender } = render(
        <Modal open={false} onClose={() => {}}>
          <Text>Content</Text>
        </Modal>
      );

      rerender(
        <Modal open={true} onClose={() => {}}>
          <Text>Content</Text>
        </Modal>
      );
      rerender(
        <Modal open={false} onClose={() => {}}>
          <Text>Content</Text>
        </Modal>
      );
      rerender(
        <Modal open={true} onClose={() => {}}>
          <Text>Content</Text>
        </Modal>
      );

      expect(screen.getByText("Content")).toBeTruthy();
    });
  });
});
```

**Step 2: Run test to verify it fails**

Run: `pnpm --filter klard-mobile test src/__tests__/components/ui/Modal.test.tsx --run`
Expected: FAIL with "Cannot find module '@/components/ui/Modal'"

**Step 3: Commit**

```bash
git add klard-mobile/src/__tests__/components/ui/Modal.test.tsx
git commit -m "test(mobile): add failing tests for Modal component"
```

---

### Task 8: Implement Modal component (Mobile)

**Files:**
- Create: `klard-mobile/src/components/ui/Modal.tsx`

**Step 1: Write minimal implementation**

```typescript
import React from "react";
import {
  Modal as RNModal,
  View,
  Text,
  Pressable,
  KeyboardAvoidingView,
  Platform,
  StyleSheet,
  ViewStyle,
  TextStyle,
} from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { Ionicons } from "@expo/vector-icons";
import * as Haptics from "expo-haptics";

import { colors, spacing, borderRadius } from "@/constants/theme";

export interface ModalProps {
  open: boolean;
  onClose: () => void;
  title?: string;
  description?: string;
  children: React.ReactNode;
  footer?: React.ReactNode;
  closeOnOverlay?: boolean;
  testID?: string;
}

function Modal({
  open,
  onClose,
  title,
  description,
  children,
  footer,
  closeOnOverlay = true,
  testID = "modal",
}: ModalProps) {
  const insets = useSafeAreaInsets();

  const handleClose = async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    onClose();
  };

  const handleOverlayPress = async () => {
    if (closeOnOverlay) {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
      onClose();
    }
  };

  return (
    <RNModal
      visible={open}
      transparent
      animationType="slide"
      onRequestClose={onClose}
      testID={testID}
    >
      <KeyboardAvoidingView
        behavior={Platform.OS === "ios" ? "padding" : "height"}
        style={styles.container}
      >
        {closeOnOverlay ? (
          <Pressable
            style={styles.overlay}
            onPress={handleOverlayPress}
            testID="modal-overlay"
          />
        ) : (
          <View style={styles.overlay} testID="modal-overlay" />
        )}

        <View
          style={[styles.content, { paddingBottom: insets.bottom + spacing.md }]}
        >
          <View style={styles.handle} testID="modal-handle" />

          <View style={styles.header}>
            {title && (
              <Text
                style={styles.title}
                testID="modal-title"
                accessibilityRole="header"
              >
                {title}
              </Text>
            )}
            <Pressable
              onPress={handleClose}
              style={styles.closeButton}
              accessibilityLabel="Close modal"
              accessibilityRole="button"
            >
              <Ionicons name="close" size={24} color={colors.slate[500]} />
            </Pressable>
          </View>

          {description && (
            <Text style={styles.description} testID="modal-description">
              {description}
            </Text>
          )}

          <View style={styles.body}>{children}</View>

          {footer && (
            <View style={styles.footer} testID="modal-footer">
              {footer}
            </View>
          )}
        </View>
      </KeyboardAvoidingView>
    </RNModal>
  );
}

interface Styles {
  container: ViewStyle;
  overlay: ViewStyle;
  content: ViewStyle;
  handle: ViewStyle;
  header: ViewStyle;
  title: TextStyle;
  closeButton: ViewStyle;
  description: TextStyle;
  body: ViewStyle;
  footer: ViewStyle;
}

const styles = StyleSheet.create<Styles>({
  container: {
    flex: 1,
    justifyContent: "flex-end",
  },
  overlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(15, 23, 42, 0.5)",
  },
  content: {
    backgroundColor: colors.white,
    borderTopLeftRadius: borderRadius.xl,
    borderTopRightRadius: borderRadius.xl,
    paddingHorizontal: spacing.lg,
    paddingTop: spacing.sm,
    maxHeight: "90%",
  },
  handle: {
    width: 40,
    height: 4,
    backgroundColor: colors.slate[300],
    borderRadius: 2,
    alignSelf: "center",
    marginBottom: spacing.md,
  },
  header: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: spacing.sm,
  },
  title: {
    fontSize: 18,
    fontWeight: "600",
    color: colors.slate[900],
    flex: 1,
  },
  closeButton: {
    padding: spacing.xs,
    marginLeft: spacing.sm,
  },
  description: {
    fontSize: 14,
    color: colors.slate[500],
    marginBottom: spacing.md,
  },
  body: {
    flex: 1,
  },
  footer: {
    paddingTop: spacing.md,
    borderTopWidth: 1,
    borderTopColor: colors.slate[200],
    marginTop: spacing.md,
  },
});

export { Modal };
```

**Step 2: Run test to verify it passes**

Run: `pnpm --filter klard-mobile test src/__tests__/components/ui/Modal.test.tsx --run`
Expected: PASS (most tests)

**Step 3: Commit**

```bash
git add klard-mobile/src/components/ui/Modal.tsx
git commit -m "feat(mobile): implement Modal component"
```

---

### Task 9: Update theme constants if needed

**Files:**
- Modify: `klard-mobile/src/constants/theme.ts` (if colors.white is missing)

**Step 1: Read current theme.ts**

Check if `colors.white` exists.

**Step 2: Add white color if missing**

```typescript
export const colors = {
  white: "#FFFFFF",
  // ... existing colors
};
```

**Step 3: Run tests**

Run: `pnpm --filter klard-mobile test src/__tests__/components/ui/Modal.test.tsx --run`
Expected: PASS

**Step 4: Commit**

```bash
git add klard-mobile/src/constants/theme.ts
git commit -m "feat(mobile): add white color to theme constants"
```

---

### Task 10: Export Modal from index.ts (Mobile)

**Files:**
- Modify: `klard-mobile/src/components/ui/index.ts`

**Step 1: Add export**

Add to the end of the file:
```typescript
export { Modal, type ModalProps } from './Modal';
```

**Step 2: Run TypeScript check**

Run: `pnpm --filter klard-mobile exec tsc --noEmit`
Expected: No errors

**Step 3: Commit**

```bash
git add klard-mobile/src/components/ui/index.ts
git commit -m "feat(mobile): export Modal from ui index"
```

---

### Task 11: Run full test suite and TypeScript check (Mobile)

**Files:** None (verification only)

**Step 1: Run all Modal tests**

Run: `pnpm --filter klard-mobile test src/__tests__/components/ui/Modal.test.tsx --run`
Expected: All tests PASS

**Step 2: Run TypeScript check**

Run: `pnpm --filter klard-mobile exec tsc --noEmit`
Expected: No errors

**Step 3: Run lint**

Run: `pnpm lint`
Expected: No errors

---

## Part 3: Finalization (2 Tasks)

### Task 12: Mark specification as DONE

**Files:**
- Modify: `docs/screens/batch/Klard_Component_Specifications.md`

**Step 1: Update marker**

Replace `<!-- IN-PROGRESS:3.2-modal-dialog -->` with `<!-- DONE:3.2-modal-dialog -->`

**Step 2: Commit**

```bash
git add docs/screens/batch/Klard_Component_Specifications.md
git commit -m "docs: mark 3.2-modal-dialog component as done"
```

---

### Task 13: Final verification and commit

**Files:** None (verification only)

**Step 1: Run all tests**

Run: `pnpm --filter klard-web test --run && pnpm --filter klard-mobile test --run`
Expected: All tests PASS

**Step 2: Run full TypeScript check**

Run: `pnpm --filter klard-web exec tsc --noEmit && pnpm --filter klard-mobile exec tsc --noEmit`
Expected: No errors

**Step 3: Verify exports work**

Create a simple import test mentally:
```typescript
// Web
import { Modal } from "@/components/ui";
// Mobile
import { Modal } from "@/components/ui";
```

---

## Verification Checklist

- [ ] Modal (Web) renders without errors
- [ ] Modal (Mobile) renders without errors
- [ ] All props implemented and typed
- [ ] All required states functional (open/close)
- [ ] Title, description, footer slots work
- [ ] Size variants work (sm, md, lg, xl, full)
- [ ] closeOnOverlay behavior works correctly
- [ ] Accessibility attributes included (role, aria-label)
- [ ] TypeScript passes with no errors
- [ ] All tests passing
- [ ] Exported from components/ui/index.ts (both platforms)
- [ ] Spec marker updated to DONE

---

## Summary

**Total Tasks:** 13
**Web Tasks:** 6
**Mobile Tasks:** 5
**Finalization Tasks:** 2

**Parallel Sub-Agent Strategy:**
- Tasks 2 and 7 (tests) can run in parallel
- Tasks 3 and 8 (implementations) can run in parallel after tests
- Tasks 5 and 10 (exports) can run in parallel
- Tasks 6 and 11 (verification) can run in parallel