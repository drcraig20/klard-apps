# 2.2 Currency Input Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Deliver a reusable CurrencyInput for web and mobile that formats numeric values with a currency symbol, clamps to optional min/max, surfaces validation via FormField, and stays accessible and variantable.

**Architecture:** Web: client component wrapping shadcn `Input` and `FormField`, with `cva` size variants and small parsing/formatting helpers. Mobile: React Native `TextInput` inside `FormField`, using sanitized parsing and fixed two-decimal formatting. Shared contract keeps props aligned across platforms; no external dependencies added.

**Tech Stack:** Next.js 16 + React 19 + shadcn/ui Input + Tailwind 4 + class-variance-authority, React Native/Expo 54 TextInput, Testing Library (web), jest-expo + RNTL (mobile), TypeScript strict.

---

- **Component:** `CurrencyInput` – controlled numeric input with currency adornment and validation messaging.
- **Platforms:** Web + Mobile.
- **Props (shared intent):**
  ```ts
  interface CurrencyInputProps {
    value: number;
    onChange: (value: number) => void;
    currency?: string; // default 'USD'
    label?: string;
    error?: string;
    helperText?: string;
    min?: number;
    max?: number;
    disabled?: boolean;
    required?: boolean;
    id?: string;           // web label association
    className?: string;    // web container/input merge
    containerStyle?: StyleProp<ViewStyle>; // mobile container style
  }
  ```
- **States:** default, focus/hover (web), disabled, error, helper, required indicator, min/max clamped, empty shows `0.00`.
- **Size variants (web via cva):** `sm` h-9 text-sm px-3, `md` h-10 text-base px-3.5 (default), `lg` h-11 text-base px-4; left padding adjusts for symbol (e.g., pl-9/10/11).
- **Color tokens:** Border `border-input`, focus ring `ring-ring/50`, text `text-slate-700` / `dark:text-slate-200`, muted `text-slate-500`, error `text-red-500`, background `bg-transparent` / `dark:bg-input/30`.
- **Accessibility:** data-slot on container/input; label `htmlFor` tied to `id`; `aria-invalid` when error; `aria-describedby` linking error/helper; `inputMode="decimal"` and `pattern="[0-9]*[.,]?[0-9]*"` (web); `keyboardType="decimal-pad"` (mobile); currency symbol is text, not aria-hidden.
- **Dependencies:** Web: `Input`, `FormField`, `cva`, `cn`. Mobile: `FormField`, `TextInput`, `StyleSheet`, `useMemo`. No new packages.

---

## SOLID Compliance Analysis

| Component | SRP | OCP | LSP | ISP | DIP |
|-----------|-----|-----|-----|-----|-----|
| CurrencyInput (Web) | Renders currency input only | Extensible via currency prop & size variants | Handles all numeric inputs | Props interface focused | Depends on Input abstraction |
| CurrencyInput (Mobile) | Renders currency input only | Extensible via currency prop | Handles all numeric inputs | Props interface focused | Depends on TextInput |
| formatCurrency (util) | Formats numbers only | N/A (pure function) | N/A | Single function | N/A |
| parseCurrency (util) | Parses strings to numbers | N/A (pure function) | N/A | Single function | N/A |

### Principle Applications

**SRP:** Each component has one responsibility - rendering a currency input field
**OCP:** Currency symbol, size variants, and formatting are configurable via props without modification
**LSP:** Component handles all valid numeric inputs without breaking
**ISP:** CurrencyInputProps contains only currency-specific properties
**DIP:** Components depend on Input/TextInput abstractions, not concrete implementations

---

## Parallel Sub-Agent Strategy

The following tasks can be parallelized:

**Batch 1 (Parallel):**
- Task 1 (Web tests) + Task 5 (Mobile tests) - Independent test files

**Batch 2 (Parallel):**
- Task 2 (Web implementation) + Task 6 (Mobile implementation) - After tests pass RED

**Batch 3 (Sequential):**
- Task 3 (Web export) → Task 4 (Web verification)
- Task 7 (Mobile export) → Task 8 (Mobile verification)

**Final (Sequential):**
- Task 9 (Update spec marker)

---

## Test Strategy (TDD)

### Tests to Write First (RED Phase):
1. Renders with currency symbol ($)
2. Formats value with 2 decimal places
3. Handles numeric input only (strips non-numeric)
4. Calls onChange with parsed number value
5. Supports different currencies (EUR, GBP, JPY)
6. Displays label and error states
7. Respects min/max validation (clamping)
8. Disabled state
9. Accessibility attributes (aria-invalid, aria-describedby, inputMode)
10. Size variants (web: sm, md, lg)
11. Edge cases (large numbers, negative values, multiple decimals)

---

## Implementation Tasks

### Task 1: Write Web CurrencyInput Tests (RED)

**Files:**
- Create: `klard-web/src/__tests__/components/ui/currency-input.test.tsx`

**Step 1: Write the failing tests**

```tsx
/**
 * Tests for CurrencyInput Component
 *
 * These tests verify:
 * 1. Renders with currency symbol
 * 2. Formats value with decimal places
 * 3. Handles numeric input parsing
 * 4. Different currency support
 * 5. Label and error display
 * 6. Min/max validation
 * 7. Disabled state
 * 8. Accessibility
 * 9. Size variants
 * 10. Edge cases
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { CurrencyInput } from '@/components/ui/currency-input';

describe('CurrencyInput', () => {
  const mockOnChange = vi.fn();

  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('Rendering', () => {
    it('should render with USD symbol by default', () => {
      render(<CurrencyInput value={0} onChange={mockOnChange} />);

      expect(screen.getByText('$')).toBeTruthy();
    });

    it('should render with label when provided', () => {
      render(<CurrencyInput value={0} onChange={mockOnChange} label="Amount" />);

      expect(screen.getByText('Amount')).toBeTruthy();
    });

    it('should render input with formatted value', () => {
      render(<CurrencyInput value={99.5} onChange={mockOnChange} />);

      const input = screen.getByRole('textbox');
      expect(input).toHaveValue('99.50');
    });

    it('should format value with 2 decimal places', () => {
      render(<CurrencyInput value={100} onChange={mockOnChange} />);

      const input = screen.getByRole('textbox');
      expect(input).toHaveValue('100.00');
    });

    it('should show 0.00 for empty/zero value', () => {
      render(<CurrencyInput value={0} onChange={mockOnChange} />);

      const input = screen.getByRole('textbox');
      expect(input).toHaveValue('0.00');
    });
  });

  describe('Currency Support', () => {
    it('should display EUR symbol for EUR currency', () => {
      render(<CurrencyInput value={0} onChange={mockOnChange} currency="EUR" />);

      expect(screen.getByText('€')).toBeTruthy();
    });

    it('should display GBP symbol for GBP currency', () => {
      render(<CurrencyInput value={0} onChange={mockOnChange} currency="GBP" />);

      expect(screen.getByText('£')).toBeTruthy();
    });

    it('should display CAD symbol for CAD currency', () => {
      render(<CurrencyInput value={0} onChange={mockOnChange} currency="CAD" />);

      expect(screen.getByText('C$')).toBeTruthy();
    });

    it('should display AUD symbol for AUD currency', () => {
      render(<CurrencyInput value={0} onChange={mockOnChange} currency="AUD" />);

      expect(screen.getByText('A$')).toBeTruthy();
    });

    it('should display currency code for unsupported currencies', () => {
      render(<CurrencyInput value={0} onChange={mockOnChange} currency="JPY" />);

      expect(screen.getByText('JPY')).toBeTruthy();
    });
  });

  describe('Input Handling', () => {
    it('should call onChange with parsed number value', () => {
      render(<CurrencyInput value={0} onChange={mockOnChange} />);

      const input = screen.getByRole('textbox');
      fireEvent.change(input, { target: { value: '123.45' } });

      expect(mockOnChange).toHaveBeenCalledWith(123.45);
    });

    it('should strip non-numeric characters except decimal', () => {
      render(<CurrencyInput value={0} onChange={mockOnChange} />);

      const input = screen.getByRole('textbox');
      fireEvent.change(input, { target: { value: '$1,234.56abc' } });

      expect(mockOnChange).toHaveBeenCalledWith(1234.56);
    });

    it('should sanitize input and call onChange with numeric value', () => {
      render(<CurrencyInput value={0} onChange={mockOnChange} />);
      const input = screen.getByRole('textbox');
      fireEvent.change(input, { target: { value: '$19.5a' } });
      expect(mockOnChange).toHaveBeenCalledWith(19.5);
    });

    it('should call onChange with 0 for empty input', () => {
      render(<CurrencyInput value={100} onChange={mockOnChange} />);

      const input = screen.getByRole('textbox');
      fireEvent.change(input, { target: { value: '' } });

      expect(mockOnChange).toHaveBeenCalledWith(0);
    });

    it('should handle decimal point only input', () => {
      render(<CurrencyInput value={0} onChange={mockOnChange} />);

      const input = screen.getByRole('textbox');
      fireEvent.change(input, { target: { value: '.' } });

      expect(mockOnChange).toHaveBeenCalledWith(0);
    });
  });

  describe('Min/Max Validation', () => {
    it('should clamp value to min when below minimum', () => {
      render(<CurrencyInput value={10} onChange={mockOnChange} min={5} />);

      const input = screen.getByRole('textbox');
      fireEvent.change(input, { target: { value: '3' } });

      expect(mockOnChange).toHaveBeenCalledWith(5);
    });

    it('should clamp value to max when above maximum', () => {
      render(<CurrencyInput value={10} onChange={mockOnChange} max={100} />);

      const input = screen.getByRole('textbox');
      fireEvent.change(input, { target: { value: '150' } });

      expect(mockOnChange).toHaveBeenCalledWith(100);
    });

    it('should allow values within min/max range', () => {
      render(<CurrencyInput value={10} onChange={mockOnChange} min={0} max={100} />);

      const input = screen.getByRole('textbox');
      fireEvent.change(input, { target: { value: '50' } });

      expect(mockOnChange).toHaveBeenCalledWith(50);
    });

    it('should clamp when both min and max are violated', () => {
      const handleChange = vi.fn();
      render(<CurrencyInput value={0} onChange={handleChange} min={10} max={20} />);
      const input = screen.getByRole('textbox');
      fireEvent.change(input, { target: { value: '2' } });
      expect(handleChange).toHaveBeenCalledWith(10);
      fireEvent.change(input, { target: { value: '99' } });
      expect(handleChange).toHaveBeenCalledWith(20);
    });
  });

  describe('Error State', () => {
    it('should display error message', () => {
      render(<CurrencyInput value={0} onChange={mockOnChange} error="Invalid amount" />);

      expect(screen.getByText('Invalid amount')).toBeTruthy();
    });

    it('should have error role on error message', () => {
      render(<CurrencyInput value={0} onChange={mockOnChange} error="Invalid amount" />);

      expect(screen.getByRole('alert')).toBeTruthy();
    });

    it('should apply error aria wiring and styles', () => {
      render(<CurrencyInput value={5} onChange={mockOnChange} error="Required" helperText="Helper" />);
      const input = screen.getByRole('textbox');
      expect(input).toHaveAttribute('aria-invalid', 'true');
      const error = screen.getByRole('alert');
      expect(error).toHaveTextContent('Required');
      expect(input.getAttribute('aria-describedby')).toContain(error.id);
      // Error should hide helper text
      expect(screen.queryByText('Helper')).toBeNull();
    });
  });

  describe('Helper Text', () => {
    it('should display helper text when no error', () => {
      render(<CurrencyInput value={0} onChange={mockOnChange} helperText="Enter amount" />);

      expect(screen.getByText('Enter amount')).toBeTruthy();
    });

    it('should hide helper text when error is present', () => {
      render(<CurrencyInput value={0} onChange={mockOnChange} helperText="Enter amount" error="Invalid" />);

      expect(screen.queryByText('Enter amount')).toBeNull();
      expect(screen.getByText('Invalid')).toBeTruthy();
    });
  });

  describe('Disabled State', () => {
    it('should be disabled when disabled prop is true', () => {
      render(<CurrencyInput value={0} onChange={mockOnChange} disabled />);

      const input = screen.getByRole('textbox');
      expect(input).toBeDisabled();
    });

    it('should have disabled styling', () => {
      render(<CurrencyInput value={0} onChange={mockOnChange} disabled />);

      const input = screen.getByRole('textbox');
      expect(input.className).toMatch(/opacity-50|cursor-not-allowed/);
    });
  });

  describe('Size Variants', () => {
    it('should apply sm size variant', () => {
      render(<CurrencyInput value={1} onChange={mockOnChange} size="sm" />);
      const input = screen.getByRole('textbox');
      expect(input.className).toMatch(/h-9/);
    });

    it('should apply md size variant by default', () => {
      render(<CurrencyInput value={1} onChange={mockOnChange} />);
      const input = screen.getByRole('textbox');
      expect(input.className).toMatch(/h-10/);
    });

    it('should apply lg size variant', () => {
      render(<CurrencyInput value={1} onChange={mockOnChange} size="lg" />);
      const input = screen.getByRole('textbox');
      expect(input.className).toMatch(/h-11/);
    });
  });

  describe('Accessibility', () => {
    it('should have inputMode decimal for mobile keyboards', () => {
      render(<CurrencyInput value={0} onChange={mockOnChange} />);

      const input = screen.getByRole('textbox');
      expect(input.getAttribute('inputMode')).toBe('decimal');
    });

    it('should link label to input via htmlFor', () => {
      render(<CurrencyInput value={0} onChange={mockOnChange} label="Price" id="price" />);

      const label = screen.getByText('Price');
      expect(label.getAttribute('for')).toBe('price');
    });

    it('should set aria-invalid when error is present', () => {
      render(<CurrencyInput value={0} onChange={mockOnChange} error="Error" />);

      const input = screen.getByRole('textbox');
      expect(input.getAttribute('aria-invalid')).toBe('true');
    });

    it('should have data-slot attribute', () => {
      render(<CurrencyInput value={0} onChange={mockOnChange} />);

      const input = screen.getByRole('textbox');
      expect(input.getAttribute('data-slot')).toBe('input');
    });
  });

  describe('Edge Cases', () => {
    it('should handle very large numbers', () => {
      render(<CurrencyInput value={999999999.99} onChange={mockOnChange} />);

      const input = screen.getByRole('textbox');
      expect(input).toHaveValue('999999999.99');
    });

    it('should handle negative values as 0', () => {
      render(<CurrencyInput value={0} onChange={mockOnChange} />);

      const input = screen.getByRole('textbox');
      fireEvent.change(input, { target: { value: '-50' } });

      expect(mockOnChange).toHaveBeenCalledWith(0);
    });

    it('should handle multiple decimal points', () => {
      render(<CurrencyInput value={0} onChange={mockOnChange} />);

      const input = screen.getByRole('textbox');
      fireEvent.change(input, { target: { value: '12.34.56' } });

      // Should take first valid decimal
      expect(mockOnChange).toHaveBeenCalledWith(12.34);
    });

    it('should round to 2 decimal places on display', () => {
      render(<CurrencyInput value={12.345} onChange={mockOnChange} />);

      const input = screen.getByRole('textbox');
      expect(input).toHaveValue('12.35');
    });
  });
});
```

**Step 2: Run test to verify it fails**

Run: `pnpm --filter klard-web test src/__tests__/components/ui/currency-input.test.tsx --run`
Expected: FAIL with "Cannot find module '@/components/ui/currency-input'"

---

### Task 2: Implement Web CurrencyInput (GREEN)

**Files:**
- Create: `klard-web/src/components/ui/currency-input.tsx`

**Step 1: Write minimal implementation**

```tsx
'use client';

import { forwardRef, useId } from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '@/lib/utils';

const currencyInputVariants = cva(
  [
    // Base styles
    'w-full text-base',
    'bg-white dark:bg-slate-900',
    'text-slate-900 dark:text-slate-100',
    'border rounded-xl',
    'placeholder:text-slate-400 dark:placeholder:text-slate-500',
    'transition-all duration-150',
    // Focus styles
    'focus:outline-none focus:ring-2 focus:ring-primary/30 focus:border-primary',
  ],
  {
    variants: {
      size: {
        sm: 'h-9 px-3 pl-8 text-sm',
        md: 'h-10 px-3.5 pl-9 text-base',
        lg: 'h-11 px-4 pl-10 text-base',
      },
      hasError: {
        true: 'border-red-500 focus:ring-red-500/30 focus:border-red-500',
        false: 'border-slate-300 dark:border-slate-700 hover:border-slate-400 dark:hover:border-slate-600',
      },
      isDisabled: {
        true: 'opacity-50 cursor-not-allowed bg-slate-50 dark:bg-slate-800',
        false: '',
      },
    },
    defaultVariants: {
      size: 'md',
      hasError: false,
      isDisabled: false,
    },
  }
);

export interface CurrencyInputProps extends VariantProps<typeof currencyInputVariants> {
  /** The numeric value */
  value: number;
  /** Callback when value changes */
  onChange: (value: number) => void;
  /** Currency code (default: 'USD') */
  currency?: string;
  /** Label text displayed above the input */
  label?: string;
  /** Error message - displays in red below input */
  error?: string;
  /** Helper text - displays below input when no error */
  helperText?: string;
  /** Minimum allowed value */
  min?: number;
  /** Maximum allowed value */
  max?: number;
  /** Disabled state */
  disabled?: boolean;
  /** Required field indicator */
  required?: boolean;
  /** Input id for label association */
  id?: string;
  /** Additional class name for input */
  className?: string;
}

// Currency symbol mapping
const currencySymbols: Record<string, string> = {
  USD: '$',
  EUR: '€',
  GBP: '£',
  CAD: 'C$',
  AUD: 'A$',
};

/**
 * Get currency symbol for a given currency code
 */
function getCurrencySymbol(currency: string): string {
  return currencySymbols[currency] || currency;
}

/**
 * Parse a string value to a number, stripping non-numeric characters
 */
function parseCurrencyValue(value: string): number {
  // Remove all non-numeric characters except decimal point
  const cleaned = value.replace(/[^0-9.]/g, '');

  // Handle multiple decimal points - take only first valid decimal portion
  const parts = cleaned.split('.');
  const normalized = parts.length > 1
    ? `${parts[0]}.${parts[1]}`
    : cleaned;

  const parsed = parseFloat(normalized);

  // Return 0 for invalid/negative values
  if (isNaN(parsed) || parsed < 0) {
    return 0;
  }

  return parsed;
}

/**
 * Clamp a value between min and max
 */
function clampValue(value: number, min?: number, max?: number): number {
  let result = value;
  if (min !== undefined && result < min) {
    result = min;
  }
  if (max !== undefined && result > max) {
    result = max;
  }
  return result;
}

export const CurrencyInput = forwardRef<HTMLInputElement, CurrencyInputProps>(
  function CurrencyInput(
    {
      value,
      onChange,
      currency = 'USD',
      label,
      error,
      helperText,
      min,
      max,
      disabled,
      required,
      id: providedId,
      className,
      size,
    },
    ref
  ) {
    const generatedId = useId();
    const id = providedId ?? generatedId;
    const errorId = `${id}-error`;
    const helperId = `${id}-helper`;
    const symbol = getCurrencySymbol(currency);

    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
      const rawValue = e.target.value;
      const parsed = parseCurrencyValue(rawValue);
      const clamped = clampValue(parsed, min, max);
      onChange(clamped);
    };

    // Format value to 2 decimal places
    const formattedValue = value.toFixed(2);

    // Determine aria-describedby
    const describedBy = error ? errorId : helperText ? helperId : undefined;

    return (
      <div className="w-full" data-slot="currency-input">
        {label && (
          <label
            htmlFor={id}
            className="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-2"
          >
            {label}
            {required && <span className="text-red-500 ml-1">*</span>}
          </label>
        )}
        <div className="relative">
          <span
            className="absolute left-3 top-1/2 -translate-y-1/2 text-slate-500 dark:text-slate-400 pointer-events-none"
          >
            {symbol}
          </span>
          <input
            ref={ref}
            id={id}
            type="text"
            inputMode="decimal"
            pattern="[0-9]*[.,]?[0-9]*"
            value={formattedValue}
            onChange={handleChange}
            disabled={disabled}
            aria-invalid={!!error}
            aria-describedby={describedBy}
            data-slot="input"
            className={cn(
              currencyInputVariants({
                size,
                hasError: !!error,
                isDisabled: disabled,
              }),
              className
            )}
          />
        </div>
        {/* Error message - takes precedence over helper */}
        {error && (
          <p
            id={errorId}
            className="mt-2 text-sm text-red-500"
            role="alert"
          >
            {error}
          </p>
        )}
        {/* Helper text - only shown when no error */}
        {!error && helperText && (
          <p
            id={helperId}
            className="mt-2 text-sm text-slate-500 dark:text-slate-400"
          >
            {helperText}
          </p>
        )}
      </div>
    );
  }
);
```

**Step 2: Run test to verify it passes**

Run: `pnpm --filter klard-web test src/__tests__/components/ui/currency-input.test.tsx --run`
Expected: PASS

**Step 3: Commit**

```bash
git add klard-web/src/__tests__/components/ui/currency-input.test.tsx klard-web/src/components/ui/currency-input.tsx
git commit -m "feat(web): add CurrencyInput component with TDD"
```

---

### Task 3: Export Web CurrencyInput

**Files:**
- Modify: `klard-web/src/components/ui/index.ts`

**Step 1: Add export**

Add to the end of the file:
```tsx
export { CurrencyInput, type CurrencyInputProps } from './currency-input';
```

**Step 2: Run TypeScript check**

Run: `pnpm --filter klard-web exec tsc --noEmit`
Expected: No errors

**Step 3: Commit**

```bash
git add klard-web/src/components/ui/index.ts
git commit -m "feat(web): export CurrencyInput from ui index"
```

---

### Task 4: Verify Web Implementation

**Step 1: Run all component tests**

Run: `pnpm --filter klard-web test --run`
Expected: All tests pass

**Step 2: Run lint**

Run: `pnpm lint`
Expected: No lint errors

---

### Task 5: Write Mobile CurrencyInput Tests (RED)

**Files:**
- Create: `klard-mobile/src/__tests__/components/ui/CurrencyInput.test.tsx`

**Step 1: Write the failing tests**

```tsx
import React from 'react';
import { render, fireEvent } from '@testing-library/react-native';
import { CurrencyInput } from '@/components/ui/CurrencyInput';

describe('CurrencyInput', () => {
  const mockOnChange = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('Rendering', () => {
    it('should render with USD symbol by default', () => {
      const { getByText } = render(
        <CurrencyInput value={0} onChange={mockOnChange} />
      );

      expect(getByText('$')).toBeTruthy();
    });

    it('should render with label when provided', () => {
      const { getByText } = render(
        <CurrencyInput value={0} onChange={mockOnChange} label="Amount" />
      );

      expect(getByText('Amount')).toBeTruthy();
    });

    it('should render input with formatted value', () => {
      const { getByTestId } = render(
        <CurrencyInput value={99.5} onChange={mockOnChange} />
      );

      const input = getByTestId('currency-input');
      expect(input.props.value).toBe('99.50');
    });

    it('should format value with 2 decimal places', () => {
      const { getByTestId } = render(
        <CurrencyInput value={100} onChange={mockOnChange} />
      );

      const input = getByTestId('currency-input');
      expect(input.props.value).toBe('100.00');
    });

    it('should show 0.00 for zero value', () => {
      const { getByTestId } = render(
        <CurrencyInput value={0} onChange={mockOnChange} />
      );

      const input = getByTestId('currency-input');
      expect(input.props.value).toBe('0.00');
    });
  });

  describe('Currency Support', () => {
    it('should display EUR symbol for EUR currency', () => {
      const { getByText } = render(
        <CurrencyInput value={0} onChange={mockOnChange} currency="EUR" />
      );

      expect(getByText('€')).toBeTruthy();
    });

    it('should display GBP symbol for GBP currency', () => {
      const { getByText } = render(
        <CurrencyInput value={0} onChange={mockOnChange} currency="GBP" />
      );

      expect(getByText('£')).toBeTruthy();
    });

    it('should display CAD symbol for CAD currency', () => {
      const { getByText } = render(
        <CurrencyInput value={0} onChange={mockOnChange} currency="CAD" />
      );

      expect(getByText('C$')).toBeTruthy();
    });

    it('should display AUD symbol for AUD currency', () => {
      const { getByText } = render(
        <CurrencyInput value={0} onChange={mockOnChange} currency="AUD" />
      );

      expect(getByText('A$')).toBeTruthy();
    });

    it('should display currency code for unsupported currencies', () => {
      const { getByText } = render(
        <CurrencyInput value={0} onChange={mockOnChange} currency="JPY" />
      );

      expect(getByText('JPY')).toBeTruthy();
    });
  });

  describe('Input Handling', () => {
    it('should call onChange with parsed number value', () => {
      const { getByTestId } = render(
        <CurrencyInput value={0} onChange={mockOnChange} />
      );

      const input = getByTestId('currency-input');
      fireEvent.changeText(input, '123.45');

      expect(mockOnChange).toHaveBeenCalledWith(123.45);
    });

    it('should strip non-numeric characters except decimal', () => {
      const { getByTestId } = render(
        <CurrencyInput value={0} onChange={mockOnChange} />
      );

      const input = getByTestId('currency-input');
      fireEvent.changeText(input, '$1,234.56abc');

      expect(mockOnChange).toHaveBeenCalledWith(1234.56);
    });

    it('should sanitize input and emit numeric value', () => {
      const { getByDisplayValue } = render(
        <CurrencyInput value={0} onChange={mockOnChange} />
      );
      const input = getByDisplayValue('0.00');
      fireEvent.changeText(input, '$19.5a');
      expect(mockOnChange).toHaveBeenCalledWith(19.5);
    });

    it('should call onChange with 0 for empty input', () => {
      const { getByTestId } = render(
        <CurrencyInput value={100} onChange={mockOnChange} />
      );

      const input = getByTestId('currency-input');
      fireEvent.changeText(input, '');

      expect(mockOnChange).toHaveBeenCalledWith(0);
    });

    it('should handle decimal point only input', () => {
      const { getByTestId } = render(
        <CurrencyInput value={0} onChange={mockOnChange} />
      );

      const input = getByTestId('currency-input');
      fireEvent.changeText(input, '.');

      expect(mockOnChange).toHaveBeenCalledWith(0);
    });
  });

  describe('Min/Max Validation', () => {
    it('should clamp value to min', () => {
      const { getByTestId } = render(
        <CurrencyInput value={10} onChange={mockOnChange} min={5} />
      );

      const input = getByTestId('currency-input');
      fireEvent.changeText(input, '3');

      expect(mockOnChange).toHaveBeenCalledWith(5);
    });

    it('should clamp value to max', () => {
      const { getByTestId } = render(
        <CurrencyInput value={10} onChange={mockOnChange} max={100} />
      );

      const input = getByTestId('currency-input');
      fireEvent.changeText(input, '150');

      expect(mockOnChange).toHaveBeenCalledWith(100);
    });

    it('should allow values within min/max range', () => {
      const { getByTestId } = render(
        <CurrencyInput value={10} onChange={mockOnChange} min={0} max={100} />
      );

      const input = getByTestId('currency-input');
      fireEvent.changeText(input, '50');

      expect(mockOnChange).toHaveBeenCalledWith(50);
    });

    it('should clamp when both min and max are set', () => {
      const { getByDisplayValue } = render(
        <CurrencyInput value={0} onChange={mockOnChange} min={10} max={20} />
      );
      const input = getByDisplayValue('0.00');
      fireEvent.changeText(input, '2');
      expect(mockOnChange).toHaveBeenCalledWith(10);
      fireEvent.changeText(input, '99');
      expect(mockOnChange).toHaveBeenCalledWith(20);
    });
  });

  describe('Error State', () => {
    it('should display error message', () => {
      const { getByText } = render(
        <CurrencyInput value={0} onChange={mockOnChange} error="Invalid amount" />
      );

      expect(getByText('Invalid amount')).toBeTruthy();
    });

    it('should have alert accessibility role on error message', () => {
      const { getByRole } = render(
        <CurrencyInput value={0} onChange={mockOnChange} error="Invalid amount" />
      );

      expect(getByRole('alert')).toBeTruthy();
    });

    it('should hide helper when error is present', () => {
      const { getByText, queryByText } = render(
        <CurrencyInput value={1} onChange={mockOnChange} error="Required" helperText="Helper" />
      );
      expect(getByText('Required')).toBeTruthy();
      expect(queryByText('Helper')).toBeNull();
    });
  });

  describe('Helper Text', () => {
    it('should display helper text when no error', () => {
      const { getByText } = render(
        <CurrencyInput value={0} onChange={mockOnChange} helperText="Enter amount" />
      );

      expect(getByText('Enter amount')).toBeTruthy();
    });
  });

  describe('Disabled State', () => {
    it('should be disabled when editable is false', () => {
      const { getByTestId } = render(
        <CurrencyInput value={0} onChange={mockOnChange} editable={false} />
      );

      const input = getByTestId('currency-input');
      expect(input.props.editable).toBe(false);
    });

    it('should be disabled when disabled prop is true', () => {
      const { getByDisplayValue } = render(
        <CurrencyInput value={1} onChange={mockOnChange} disabled />
      );
      const input = getByDisplayValue('1.00');
      expect(input.props.editable).toBe(false);
    });

    it('should have reduced opacity when disabled', () => {
      const { getByTestId } = render(
        <CurrencyInput value={0} onChange={mockOnChange} disabled />
      );

      // Check parent container has opacity styling
      const input = getByTestId('currency-input');
      expect(input).toBeTruthy();
    });
  });

  describe('Accessibility', () => {
    it('should use decimal-pad keyboard type', () => {
      const { getByTestId } = render(
        <CurrencyInput value={0} onChange={mockOnChange} />
      );

      const input = getByTestId('currency-input');
      expect(input.props.keyboardType).toBe('decimal-pad');
    });

    it('should have accessibilityLabel from label prop', () => {
      const { getByTestId } = render(
        <CurrencyInput value={0} onChange={mockOnChange} label="Price" />
      );

      const input = getByTestId('currency-input');
      expect(input.props.accessibilityLabel).toBe('Price');
    });

    it('should indicate error state in accessibility', () => {
      const { getByTestId } = render(
        <CurrencyInput value={0} onChange={mockOnChange} error="Invalid" label="Amount" />
      );

      const input = getByTestId('currency-input');
      // Check accessibility state indicates error
      expect(input.props.accessibilityState?.invalid || input.props['aria-invalid']).toBeTruthy();
    });
  });

  describe('Edge Cases', () => {
    it('should handle very large numbers', () => {
      const { getByTestId } = render(
        <CurrencyInput value={999999999.99} onChange={mockOnChange} />
      );

      const input = getByTestId('currency-input');
      expect(input.props.value).toBe('999999999.99');
    });

    it('should handle negative input as 0', () => {
      const { getByTestId } = render(
        <CurrencyInput value={0} onChange={mockOnChange} />
      );

      const input = getByTestId('currency-input');
      fireEvent.changeText(input, '-50');

      expect(mockOnChange).toHaveBeenCalledWith(0);
    });

    it('should handle multiple decimal points', () => {
      const { getByTestId } = render(
        <CurrencyInput value={0} onChange={mockOnChange} />
      );

      const input = getByTestId('currency-input');
      fireEvent.changeText(input, '12.34.56');

      // Should take first valid decimal
      expect(mockOnChange).toHaveBeenCalledWith(12.34);
    });
  });
});
```

**Step 2: Run test to verify it fails**

Run: `pnpm --filter klard-mobile test src/__tests__/components/ui/CurrencyInput.test.tsx --run`
Expected: FAIL with "Cannot find module '@/components/ui/CurrencyInput'"

---

### Task 6: Implement Mobile CurrencyInput (GREEN)

**Files:**
- Create: `klard-mobile/src/components/ui/CurrencyInput.tsx`

**Step 1: Write minimal implementation**

```tsx
import React, { useState } from 'react';
import {
  View,
  Text,
  TextInput,
  StyleSheet,
  type TextInputProps,
  type StyleProp,
  type ViewStyle,
} from 'react-native';

export interface CurrencyInputProps extends Omit<TextInputProps, 'value' | 'onChangeText'> {
  /** The numeric value */
  value: number;
  /** Callback when value changes */
  onChange: (value: number) => void;
  /** Currency code (default: 'USD') */
  currency?: string;
  /** Label text displayed above the input */
  label?: string;
  /** Error message - displays in red below input */
  error?: string;
  /** Helper text - displays below input when no error */
  helperText?: string;
  /** Minimum allowed value */
  min?: number;
  /** Maximum allowed value */
  max?: number;
  /** Disabled state (alternative to editable) */
  disabled?: boolean;
  /** Required field indicator */
  required?: boolean;
  /** Container style override */
  containerStyle?: StyleProp<ViewStyle>;
}

// Currency symbol mapping
const currencySymbols: Record<string, string> = {
  USD: '$',
  EUR: '€',
  GBP: '£',
  CAD: 'C$',
  AUD: 'A$',
};

/**
 * Get currency symbol for a given currency code
 */
function getCurrencySymbol(currency: string): string {
  return currencySymbols[currency] || currency;
}

/**
 * Parse a string value to a number, stripping non-numeric characters
 */
function parseCurrencyValue(value: string): number {
  // Remove all non-numeric characters except decimal point
  const cleaned = value.replace(/[^0-9.]/g, '');

  // Handle multiple decimal points - take only first valid decimal portion
  const parts = cleaned.split('.');
  const normalized = parts.length > 1
    ? `${parts[0]}.${parts[1]}`
    : cleaned;

  const parsed = parseFloat(normalized);

  // Return 0 for invalid/negative values
  if (isNaN(parsed) || parsed < 0) {
    return 0;
  }

  return parsed;
}

/**
 * Clamp a value between min and max
 */
function clampValue(value: number, min?: number, max?: number): number {
  let result = value;
  if (min !== undefined && result < min) {
    result = min;
  }
  if (max !== undefined && result > max) {
    result = max;
  }
  return result;
}

export function CurrencyInput({
  value,
  onChange,
  currency = 'USD',
  label,
  error,
  helperText,
  min,
  max,
  disabled,
  required,
  containerStyle,
  editable = true,
  onFocus,
  onBlur,
  ...props
}: CurrencyInputProps) {
  const [isFocused, setIsFocused] = useState(false);
  const symbol = getCurrencySymbol(currency);

  const handleChangeText = (text: string) => {
    const parsed = parseCurrencyValue(text);
    const clamped = clampValue(parsed, min, max);
    onChange(clamped);
  };

  const handleFocus = (e: any) => {
    setIsFocused(true);
    onFocus?.(e);
  };

  const handleBlur = (e: any) => {
    setIsFocused(false);
    onBlur?.(e);
  };

  // Format value to 2 decimal places
  const formattedValue = value.toFixed(2);

  // Dynamic border color
  const getBorderColor = () => {
    if (error) return colors.error;
    if (isFocused) return colors.primary;
    return colors.border;
  };

  // Determine if input is disabled (either via disabled or editable prop)
  const isDisabled = disabled || !editable;

  return (
    <View style={[styles.container, containerStyle]}>
      {/* Label */}
      {label && (
        <Text style={[styles.label, isDisabled && styles.labelDisabled]}>
          {label}
          {required && <Text style={styles.required}> *</Text>}
        </Text>
      )}

      {/* Input container */}
      <View
        style={[
          styles.inputContainer,
          {
            borderColor: getBorderColor(),
            borderWidth: isFocused ? 2 : 1,
          },
          isDisabled && styles.inputContainerDisabled,
        ]}
      >
        {/* Currency symbol */}
        <Text style={styles.symbol}>{symbol}</Text>

        {/* TextInput */}
        <TextInput
          value={formattedValue}
          onChangeText={handleChangeText}
          onFocus={handleFocus}
          onBlur={handleBlur}
          editable={!isDisabled}
          keyboardType="decimal-pad"
          placeholderTextColor={colors.placeholder}
          style={[
            styles.input,
            isDisabled ? styles.inputDisabled : undefined,
          ]}
          accessibilityLabel={label}
          accessibilityState={{
            disabled: isDisabled,
            invalid: !!error,
          }}
          testID="currency-input"
          {...props}
        />
      </View>

      {/* Error message - takes precedence over helper */}
      {error && (
        <Text style={styles.error} accessibilityRole="alert">
          {error}
        </Text>
      )}

      {/* Helper text - only shown when no error */}
      {!error && helperText && (
        <Text style={styles.helper}>
          {helperText}
        </Text>
      )}
    </View>
  );
}

// Color constants aligned with Klard design system
const colors = {
  primary: '#0D7C7A',
  error: '#DC2626',
  border: '#CBD5E1',
  placeholder: '#94A3B8',
  text: '#0F172A',
  textSecondary: '#475569',
  background: '#FFFFFF',
  backgroundDisabled: '#F1F5F9',
};

const styles = StyleSheet.create({
  container: {
    width: '100%',
  },
  label: {
    fontSize: 14,
    fontWeight: '500',
    color: colors.textSecondary,
    marginBottom: 8,
  },
  labelDisabled: {
    opacity: 0.5,
  },
  required: {
    color: colors.error,
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: colors.background,
    borderRadius: 12,
    height: 48,
  },
  inputContainerDisabled: {
    backgroundColor: colors.backgroundDisabled,
    opacity: 0.7,
  },
  symbol: {
    fontSize: 16,
    color: colors.textSecondary,
    paddingLeft: 12,
  },
  input: {
    flex: 1,
    height: '100%',
    paddingHorizontal: 8,
    paddingRight: 16,
    fontSize: 16,
    color: colors.text,
  },
  inputDisabled: {
    color: colors.placeholder,
  },
  error: {
    fontSize: 14,
    color: colors.error,
    marginTop: 8,
  },
  helper: {
    fontSize: 14,
    color: colors.textSecondary,
    marginTop: 8,
  },
});
```

**Step 2: Run test to verify it passes**

Run: `pnpm --filter klard-mobile test src/__tests__/components/ui/CurrencyInput.test.tsx --run`
Expected: PASS

**Step 3: Commit**

```bash
git add klard-mobile/src/__tests__/components/ui/CurrencyInput.test.tsx klard-mobile/src/components/ui/CurrencyInput.tsx
git commit -m "feat(mobile): add CurrencyInput component with TDD"
```

---

### Task 7: Export Mobile CurrencyInput

**Files:**
- Modify: `klard-mobile/src/components/ui/index.ts`

**Step 1: Add export**

Add to the end of the file:
```tsx
export { CurrencyInput, type CurrencyInputProps } from './CurrencyInput';
```

**Step 2: Run TypeScript check**

Run: `pnpm --filter klard-mobile exec tsc --noEmit`
Expected: No errors

**Step 3: Commit**

```bash
git add klard-mobile/src/components/ui/index.ts
git commit -m "feat(mobile): export CurrencyInput from ui index"
```

---

### Task 8: Verify Mobile Implementation

**Step 1: Run all component tests**

Run: `pnpm --filter klard-mobile test --run`
Expected: All tests pass

**Step 2: Run lint**

Run: `pnpm lint`
Expected: No lint errors

---

### Task 9: Update Specification Marker

**Files:**
- Modify: `docs/screens/batch/Klard_Component_Specifications.md`

**Step 1: Update marker**

Replace `<!-- IN-PROGRESS:2.2-currency-input -->` with `<!-- DONE:2.2-currency-input -->`

**Step 2: Commit**

```bash
git add docs/screens/batch/Klard_Component_Specifications.md
git commit -m "docs: mark 2.2-currency-input component as done"
```

---

## Verification Checklist

Before marking complete, verify all items:

- [ ] Web component renders without errors
- [ ] Mobile component renders without errors
- [ ] All props implemented and typed (value, onChange, currency, label, error, helperText, min, max, disabled, required)
- [ ] Size variants functional (web: sm, md, lg)
- [ ] All required states functional (default, focused, error, disabled, helper)
- [ ] Matches specification visually
- [ ] Accessibility attributes included (aria-invalid, aria-describedby, role="alert", inputMode, keyboardType)
- [ ] TypeScript passes: `pnpm --filter klard-web exec tsc --noEmit`
- [ ] TypeScript passes: `pnpm --filter klard-mobile exec tsc --noEmit`
- [ ] All web tests pass: `pnpm --filter klard-web test --run`
- [ ] All mobile tests pass: `pnpm --filter klard-mobile test --run`
- [ ] Exported from components/ui/index.ts (both platforms)
- [ ] Spec marker updated to DONE

---

## Post-Implementation

After all tasks complete:
1. Run full test suite: `pnpm test --run`
2. Run lint: `pnpm lint`
3. Run build: `pnpm build`
4. Create final commit if needed