# 4.5 Tooltip Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a production-ready Tooltip component for both Web (shadcn/ui) and Mobile (React Native with expo-haptics) platforms that provides contextual help on hover/long-press.

**Architecture:** Web uses shadcn/ui's Tooltip with Radix UI primitives. Mobile implements a custom Tooltip using Pressable with long-press gesture, haptic feedback via expo-haptics, and animated positioning. Both share consistent API through TooltipProps interface.

**Tech Stack:**
- Web: shadcn/ui Tooltip, @radix-ui/react-tooltip, Tailwind CSS, CVA
- Mobile: React Native Pressable, expo-haptics, Animated API, StyleSheet

---

## SOLID Compliance

| Component | SRP | OCP | LSP | ISP | DIP |
|-----------|-----|-----|-----|-----|-----|
| Tooltip (Web) | Renders tooltip only | Extensible via side/align props | Handles all trigger types | Single TooltipProps interface | Depends on TooltipProps abstraction |
| Tooltip (Mobile) | Manages tooltip visibility | Side prop for positioning | Handles all children types | Single TooltipProps interface | Depends on TooltipProps abstraction |

### Principle Applications

**SRP:** Each component has single responsibility - display contextual help
**OCP:** Positioning/styling extensible via props without modification
**LSP:** All prop combinations work consistently
**ISP:** Single focused interface with only necessary props
**DIP:** Components depend on TooltipProps interface, not concrete implementations

---

## Parallel Sub-Agent Strategy

**Task Groups for Parallel Execution:**
- Group A (Web): Tasks 1-5 (Web tests + implementation)
- Group B (Mobile): Tasks 6-10 (Mobile tests + implementation)
- Group C (Integration): Tasks 11-12 (Exports + Final verification)

Groups A and B can run in parallel. Group C runs after both complete.

---

## Tasks

### Task 1: Create Web Tooltip Test File (RED)

**Files:**
- Create: `klard-web/src/__tests__/components/ui/tooltip.test.tsx`

**Step 1: Write the failing test**

```tsx
/**
 * Tests for Tooltip Component (Web)
 *
 * TDD: Write failing tests first, then implement to pass.
 * Tests verify: rendering, positioning, content, accessibility
 */

import { describe, it, expect } from "vitest"
import { render, screen, waitFor } from "@testing-library/react"
import userEvent from "@testing-library/user-event"
import { Tooltip, TooltipContent, TooltipTrigger, TooltipProvider } from "@/components/ui/tooltip"
import { Button } from "@/components/ui/button"

describe("Tooltip", () => {
  describe("Rendering", () => {
    it("should render trigger element", () => {
      render(
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent>Tooltip content</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      expect(screen.getByRole("button", { name: "Hover me" })).toBeInTheDocument()
    })

    it("should not show tooltip content initially", () => {
      render(
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent>Hidden content</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      expect(screen.queryByText("Hidden content")).not.toBeInTheDocument()
    })

    it("should show tooltip content on hover", async () => {
      const user = userEvent.setup()

      render(
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent>Tooltip content</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      await user.hover(screen.getByRole("button"))

      await waitFor(() => {
        expect(screen.getByRole("tooltip")).toBeInTheDocument()
        expect(screen.getByText("Tooltip content")).toBeInTheDocument()
      })
    })

    it("should hide tooltip on mouse leave", async () => {
      const user = userEvent.setup()

      render(
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent>Tooltip content</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      await user.hover(screen.getByRole("button"))
      await waitFor(() => {
        expect(screen.getByText("Tooltip content")).toBeInTheDocument()
      })

      await user.unhover(screen.getByRole("button"))
      await waitFor(() => {
        expect(screen.queryByText("Tooltip content")).not.toBeInTheDocument()
      })
    })
  })

  describe("Positioning", () => {
    it("should render with default top position", async () => {
      const user = userEvent.setup()

      render(
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent>Top tooltip</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      await user.hover(screen.getByRole("button"))

      await waitFor(() => {
        const tooltip = screen.getByRole("tooltip")
        expect(tooltip).toHaveAttribute("data-side", "top")
      })
    })

    it("should render with bottom position when specified", async () => {
      const user = userEvent.setup()

      render(
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent side="bottom">Bottom tooltip</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      await user.hover(screen.getByRole("button"))

      await waitFor(() => {
        const tooltip = screen.getByRole("tooltip")
        expect(tooltip).toHaveAttribute("data-side", "bottom")
      })
    })

    it("should render with left position when specified", async () => {
      const user = userEvent.setup()

      render(
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent side="left">Left tooltip</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      await user.hover(screen.getByRole("button"))

      await waitFor(() => {
        const tooltip = screen.getByRole("tooltip")
        expect(tooltip).toHaveAttribute("data-side", "left")
      })
    })

    it("should render with right position when specified", async () => {
      const user = userEvent.setup()

      render(
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent side="right">Right tooltip</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      await user.hover(screen.getByRole("button"))

      await waitFor(() => {
        const tooltip = screen.getByRole("tooltip")
        expect(tooltip).toHaveAttribute("data-side", "right")
      })
    })
  })

  describe("Content", () => {
    it("should render string content", async () => {
      const user = userEvent.setup()

      render(
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent>Simple text</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      await user.hover(screen.getByRole("button"))

      await waitFor(() => {
        expect(screen.getByText("Simple text")).toBeInTheDocument()
      })
    })

    it("should render complex content", async () => {
      const user = userEvent.setup()

      render(
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent>
              <div>
                <strong>Title</strong>
                <p>Description text</p>
              </div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      await user.hover(screen.getByRole("button"))

      await waitFor(() => {
        expect(screen.getByText("Title")).toBeInTheDocument()
        expect(screen.getByText("Description text")).toBeInTheDocument()
      })
    })
  })

  describe("Accessibility", () => {
    it("should have role tooltip when visible", async () => {
      const user = userEvent.setup()

      render(
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent>Accessible tooltip</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      await user.hover(screen.getByRole("button"))

      await waitFor(() => {
        expect(screen.getByRole("tooltip")).toBeInTheDocument()
      })
    })

    it("should show tooltip on focus", async () => {
      const user = userEvent.setup()

      render(
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Focus me</Button>
            </TooltipTrigger>
            <TooltipContent>Focus tooltip</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      await user.tab()

      await waitFor(() => {
        expect(screen.getByRole("tooltip")).toBeInTheDocument()
      })
    })
  })

  describe("Custom className", () => {
    it("should merge custom className with default classes", async () => {
      const user = userEvent.setup()

      render(
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent className="custom-tooltip">Content</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      await user.hover(screen.getByRole("button"))

      await waitFor(() => {
        const tooltip = screen.getByRole("tooltip")
        expect(tooltip.className).toContain("custom-tooltip")
      })
    })
  })

  describe("sideOffset", () => {
    it("should apply sideOffset prop", async () => {
      const user = userEvent.setup()

      render(
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent sideOffset={10}>Offset tooltip</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      await user.hover(screen.getByRole("button"))

      await waitFor(() => {
        expect(screen.getByRole("tooltip")).toBeInTheDocument()
      })
    })
  })
})
```

**Step 2: Run test to verify it fails**

Run: `pnpm --filter klard-web test src/__tests__/components/ui/tooltip.test.tsx --run`
Expected: FAIL - Tooltip component doesn't exist yet

---

### Task 2: Install shadcn/ui Tooltip Component

**Files:**
- Create: `klard-web/src/components/ui/tooltip.tsx` (via CLI)

**Step 1: Install the shadcn/ui tooltip component**

```bash
cd klard-web && npx shadcn@latest add tooltip
```

**Step 2: Verify installation creates the tooltip.tsx file**

The CLI should create `klard-web/src/components/ui/tooltip.tsx`

**Step 3: Run tests to verify basic functionality works**

Run: `pnpm --filter klard-web test src/__tests__/components/ui/tooltip.test.tsx --run`
Expected: Most tests should PASS now

---

### Task 3: Customize Web Tooltip Styling (GREEN)

**Files:**
- Modify: `klard-web/src/components/ui/tooltip.tsx`

**Step 1: Read the generated tooltip file**

Read the file to understand current implementation.

**Step 2: Customize for Klard design system**

Update the TooltipContent component with Klard styling:

```tsx
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ComponentRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Portal>
    <TooltipPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 overflow-hidden rounded-md bg-slate-900 px-3 py-1.5 text-xs text-slate-50 animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 dark:bg-slate-50 dark:text-slate-900",
        className
      )}
      data-slot="tooltip"
      {...props}
    />
  </TooltipPrimitive.Portal>
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
```

**Step 3: Run tests to verify all pass**

Run: `pnpm --filter klard-web test src/__tests__/components/ui/tooltip.test.tsx --run`
Expected: PASS

**Step 4: Commit**

```bash
git add klard-web/src/components/ui/tooltip.tsx klard-web/src/__tests__/components/ui/tooltip.test.tsx
git commit -m "feat(web): add tooltip component with tests"
```

---

### Task 4: Add TooltipWrapper Convenience Component

**Files:**
- Modify: `klard-web/src/components/ui/tooltip.tsx`

**Step 1: Add test for TooltipWrapper**

Add to `klard-web/src/__tests__/components/ui/tooltip.test.tsx`:

```tsx
import { TooltipWrapper } from "@/components/ui/tooltip"

describe("TooltipWrapper", () => {
  it("should render with simplified API", async () => {
    const user = userEvent.setup()

    render(
      <TooltipWrapper content="Wrapper tooltip">
        <Button>Simple trigger</Button>
      </TooltipWrapper>
    )

    await user.hover(screen.getByRole("button"))

    await waitFor(() => {
      expect(screen.getByText("Wrapper tooltip")).toBeInTheDocument()
    })
  })

  it("should accept side prop", async () => {
    const user = userEvent.setup()

    render(
      <TooltipWrapper content="Bottom tooltip" side="bottom">
        <Button>Trigger</Button>
      </TooltipWrapper>
    )

    await user.hover(screen.getByRole("button"))

    await waitFor(() => {
      const tooltip = screen.getByRole("tooltip")
      expect(tooltip).toHaveAttribute("data-side", "bottom")
    })
  })

  it("should accept delayDuration prop", async () => {
    const user = userEvent.setup()

    render(
      <TooltipWrapper content="Delayed tooltip" delayDuration={0}>
        <Button>Trigger</Button>
      </TooltipWrapper>
    )

    await user.hover(screen.getByRole("button"))

    await waitFor(() => {
      expect(screen.getByText("Delayed tooltip")).toBeInTheDocument()
    })
  })
})
```

**Step 2: Run tests to verify they fail**

Run: `pnpm --filter klard-web test src/__tests__/components/ui/tooltip.test.tsx --run`
Expected: FAIL - TooltipWrapper not defined

**Step 3: Implement TooltipWrapper**

Add to `klard-web/src/components/ui/tooltip.tsx`:

```tsx
export interface TooltipWrapperProps {
  content: React.ReactNode
  children: React.ReactNode
  side?: "top" | "bottom" | "left" | "right"
  sideOffset?: number
  delayDuration?: number
  className?: string
}

const TooltipWrapper = ({
  content,
  children,
  side = "top",
  sideOffset = 4,
  delayDuration = 200,
  className,
}: TooltipWrapperProps) => (
  <TooltipProvider delayDuration={delayDuration}>
    <Tooltip>
      <TooltipTrigger asChild>{children}</TooltipTrigger>
      <TooltipContent side={side} sideOffset={sideOffset} className={className}>
        {content}
      </TooltipContent>
    </Tooltip>
  </TooltipProvider>
)

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider, TooltipWrapper }
```

**Step 4: Run tests to verify all pass**

Run: `pnpm --filter klard-web test src/__tests__/components/ui/tooltip.test.tsx --run`
Expected: PASS

**Step 5: Commit**

```bash
git add klard-web/src/components/ui/tooltip.tsx klard-web/src/__tests__/components/ui/tooltip.test.tsx
git commit -m "feat(web): add TooltipWrapper convenience component"
```

---

### Task 5: Export Web Tooltip from Index

**Files:**
- Modify: `klard-web/src/components/ui/index.ts`

**Step 1: Add export statement**

Add to `klard-web/src/components/ui/index.ts`:

```tsx
export {
  Tooltip,
  TooltipTrigger,
  TooltipContent,
  TooltipProvider,
  TooltipWrapper,
  type TooltipWrapperProps,
} from './tooltip';
```

**Step 2: Run TypeScript check**

Run: `pnpm --filter klard-web exec tsc --noEmit`
Expected: No errors

**Step 3: Commit**

```bash
git add klard-web/src/components/ui/index.ts
git commit -m "feat(web): export tooltip from ui index"
```

---

### Task 6: Create Mobile Tooltip Test File (RED)

**Files:**
- Create: `klard-mobile/src/__tests__/components/ui/Tooltip.test.tsx`

**Step 1: Write the failing test**

```tsx
/**
 * Tests for Tooltip Component (Mobile)
 *
 * TDD: Write failing tests first, then implement to pass.
 */

import React from 'react';
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react-native';
import { Text, View } from 'react-native';
import { Tooltip } from '@/components/ui/Tooltip';
import * as Haptics from 'expo-haptics';

// Mock expo-haptics
jest.mock('expo-haptics', () => ({
  impactAsync: jest.fn(),
  ImpactFeedbackStyle: {
    Light: 'light',
    Medium: 'medium',
    Heavy: 'heavy',
  },
}));

// Mock Animated to avoid timing issues in tests
jest.mock('react-native', () => {
  const RN = jest.requireActual('react-native');
  RN.Animated.timing = () => ({
    start: (callback?: () => void) => callback?.(),
  });
  return RN;
});

describe('Tooltip', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    jest.useFakeTimers();
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  describe('Rendering', () => {
    it('should render children', () => {
      render(
        <Tooltip content="Tooltip text">
          <Text>Trigger</Text>
        </Tooltip>
      );

      expect(screen.getByText('Trigger')).toBeTruthy();
    });

    it('should not show tooltip content initially', () => {
      render(
        <Tooltip content="Hidden content">
          <Text>Trigger</Text>
        </Tooltip>
      );

      expect(screen.queryByText('Hidden content')).toBeNull();
    });

    it('should have correct testID when provided', () => {
      render(
        <Tooltip content="Content" testID="my-tooltip">
          <Text>Trigger</Text>
        </Tooltip>
      );

      expect(screen.getByTestId('my-tooltip')).toBeTruthy();
    });
  });

  describe('Long Press Interaction', () => {
    it('should show tooltip on long press', async () => {
      render(
        <Tooltip content="Visible content">
          <Text>Press and hold</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Press and hold');

      await act(async () => {
        fireEvent(trigger, 'longPress');
      });

      expect(screen.getByText('Visible content')).toBeTruthy();
    });

    it('should trigger haptic feedback on long press', async () => {
      render(
        <Tooltip content="Haptic tooltip">
          <Text>Trigger</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Trigger');

      await act(async () => {
        fireEvent(trigger, 'longPress');
      });

      expect(Haptics.impactAsync).toHaveBeenCalledWith(
        Haptics.ImpactFeedbackStyle.Light
      );
    });

    it('should hide tooltip after duration', async () => {
      render(
        <Tooltip content="Disappearing content" duration={2000}>
          <Text>Trigger</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Trigger');

      await act(async () => {
        fireEvent(trigger, 'longPress');
      });

      expect(screen.getByText('Disappearing content')).toBeTruthy();

      await act(async () => {
        jest.advanceTimersByTime(2000);
      });

      expect(screen.queryByText('Disappearing content')).toBeNull();
    });

    it('should use default duration of 2000ms', async () => {
      render(
        <Tooltip content="Default duration">
          <Text>Trigger</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Trigger');

      await act(async () => {
        fireEvent(trigger, 'longPress');
      });

      expect(screen.getByText('Default duration')).toBeTruthy();

      // Should still be visible at 1900ms
      await act(async () => {
        jest.advanceTimersByTime(1900);
      });
      expect(screen.getByText('Default duration')).toBeTruthy();

      // Should be hidden at 2000ms
      await act(async () => {
        jest.advanceTimersByTime(100);
      });
      expect(screen.queryByText('Default duration')).toBeNull();
    });
  });

  describe('Content Types', () => {
    it('should render string content', async () => {
      render(
        <Tooltip content="String content">
          <Text>Trigger</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Trigger');

      await act(async () => {
        fireEvent(trigger, 'longPress');
      });

      expect(screen.getByText('String content')).toBeTruthy();
    });

    it('should render React node content', async () => {
      render(
        <Tooltip
          content={
            <View testID="complex-content">
              <Text>Complex</Text>
            </View>
          }
        >
          <Text>Trigger</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Trigger');

      await act(async () => {
        fireEvent(trigger, 'longPress');
      });

      expect(screen.getByTestId('complex-content')).toBeTruthy();
      expect(screen.getByText('Complex')).toBeTruthy();
    });
  });

  describe('Accessibility', () => {
    it('should have accessible label on trigger', () => {
      render(
        <Tooltip content="Help text" accessibilityLabel="Show help">
          <Text>?</Text>
        </Tooltip>
      );

      expect(screen.getByLabelText('Show help')).toBeTruthy();
    });

    it('should announce tooltip content to screen reader', async () => {
      render(
        <Tooltip content="Screen reader content">
          <Text>Trigger</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Trigger');

      await act(async () => {
        fireEvent(trigger, 'longPress');
      });

      const tooltip = screen.getByText('Screen reader content');
      expect(tooltip).toBeTruthy();
    });
  });

  describe('Disabled State', () => {
    it('should not show tooltip when disabled', async () => {
      render(
        <Tooltip content="Disabled content" disabled>
          <Text>Trigger</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Trigger');

      await act(async () => {
        fireEvent(trigger, 'longPress');
      });

      expect(screen.queryByText('Disabled content')).toBeNull();
    });

    it('should not trigger haptics when disabled', async () => {
      render(
        <Tooltip content="No haptics" disabled>
          <Text>Trigger</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Trigger');

      await act(async () => {
        fireEvent(trigger, 'longPress');
      });

      expect(Haptics.impactAsync).not.toHaveBeenCalled();
    });
  });

  describe('Callbacks', () => {
    it('should call onShow when tooltip appears', async () => {
      const onShow = jest.fn();

      render(
        <Tooltip content="Callback test" onShow={onShow}>
          <Text>Trigger</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Trigger');

      await act(async () => {
        fireEvent(trigger, 'longPress');
      });

      expect(onShow).toHaveBeenCalledTimes(1);
    });

    it('should call onHide when tooltip disappears', async () => {
      const onHide = jest.fn();

      render(
        <Tooltip content="Hide callback" duration={1000} onHide={onHide}>
          <Text>Trigger</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Trigger');

      await act(async () => {
        fireEvent(trigger, 'longPress');
      });

      expect(onHide).not.toHaveBeenCalled();

      await act(async () => {
        jest.advanceTimersByTime(1000);
      });

      expect(onHide).toHaveBeenCalledTimes(1);
    });
  });

  describe('Edge Cases', () => {
    it('should handle rapid long presses', async () => {
      render(
        <Tooltip content="Rapid press test" duration={500}>
          <Text>Trigger</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Trigger');

      // First long press
      await act(async () => {
        fireEvent(trigger, 'longPress');
      });
      expect(screen.getByText('Rapid press test')).toBeTruthy();

      // Second long press before timeout
      await act(async () => {
        jest.advanceTimersByTime(200);
        fireEvent(trigger, 'longPress');
      });

      // Should still be visible
      expect(screen.getByText('Rapid press test')).toBeTruthy();
    });

    it('should handle empty content gracefully', async () => {
      render(
        <Tooltip content="">
          <Text>Trigger</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Trigger');

      await act(async () => {
        fireEvent(trigger, 'longPress');
      });

      // Should not crash, trigger still visible
      expect(screen.getByText('Trigger')).toBeTruthy();
    });
  });
});
```

**Step 2: Run test to verify it fails**

Run: `pnpm --filter klard-mobile test src/__tests__/components/ui/Tooltip.test.tsx --run`
Expected: FAIL - Tooltip component doesn't exist

---

### Task 7: Create Mobile Tooltip Component (GREEN)

**Files:**
- Create: `klard-mobile/src/components/ui/Tooltip.tsx`

**Step 1: Create the Tooltip component**

```tsx
import React, { useState, useCallback, useRef, useEffect } from 'react';
import {
  View,
  Text,
  Pressable,
  StyleSheet,
  Animated,
  ViewStyle,
  TextStyle,
  AccessibilityInfo,
} from 'react-native';
import * as Haptics from 'expo-haptics';

export interface TooltipProps {
  /** Content to display in the tooltip */
  content: React.ReactNode;
  /** Trigger element */
  children: React.ReactNode;
  /** Duration in ms before tooltip auto-hides (default: 2000) */
  duration?: number;
  /** Disable tooltip interaction */
  disabled?: boolean;
  /** Callback when tooltip shows */
  onShow?: () => void;
  /** Callback when tooltip hides */
  onHide?: () => void;
  /** Test ID for testing */
  testID?: string;
  /** Accessibility label for trigger */
  accessibilityLabel?: string;
  /** Custom styles for tooltip container */
  style?: ViewStyle;
  /** Custom styles for tooltip text */
  textStyle?: TextStyle;
}

export function Tooltip({
  content,
  children,
  duration = 2000,
  disabled = false,
  onShow,
  onHide,
  testID,
  accessibilityLabel,
  style,
  textStyle,
}: TooltipProps) {
  const [visible, setVisible] = useState(false);
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const hideTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const clearHideTimeout = useCallback(() => {
    if (hideTimeoutRef.current) {
      clearTimeout(hideTimeoutRef.current);
      hideTimeoutRef.current = null;
    }
  }, []);

  const showTooltip = useCallback(() => {
    clearHideTimeout();
    setVisible(true);

    Animated.timing(fadeAnim, {
      toValue: 1,
      duration: 150,
      useNativeDriver: true,
    }).start();

    onShow?.();

    hideTimeoutRef.current = setTimeout(() => {
      hideTooltip();
    }, duration);
  }, [duration, onShow, fadeAnim, clearHideTimeout]);

  const hideTooltip = useCallback(() => {
    clearHideTimeout();

    Animated.timing(fadeAnim, {
      toValue: 0,
      duration: 150,
      useNativeDriver: true,
    }).start(() => {
      setVisible(false);
      onHide?.();
    });
  }, [onHide, fadeAnim, clearHideTimeout]);

  const handleLongPress = useCallback(async () => {
    if (disabled) return;

    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    showTooltip();

    // Announce to screen reader
    if (typeof content === 'string') {
      AccessibilityInfo.announceForAccessibility(content);
    }
  }, [disabled, content, showTooltip]);

  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      clearHideTimeout();
    };
  }, [clearHideTimeout]);

  const renderContent = () => {
    if (typeof content === 'string') {
      return <Text style={[styles.tooltipText, textStyle]}>{content}</Text>;
    }
    return content;
  };

  return (
    <View testID={testID} style={styles.container}>
      <Pressable
        onLongPress={handleLongPress}
        accessibilityLabel={accessibilityLabel}
        accessibilityRole="button"
        accessibilityHint="Long press to show tooltip"
      >
        {children}
      </Pressable>
      {visible && (
        <Animated.View
          style={[
            styles.tooltip,
            style,
            {
              opacity: fadeAnim,
              transform: [
                {
                  scale: fadeAnim.interpolate({
                    inputRange: [0, 1],
                    outputRange: [0.95, 1],
                  }),
                },
              ],
            },
          ]}
          accessibilityRole="alert"
          accessibilityLiveRegion="polite"
        >
          {renderContent()}
          <View style={styles.arrow} />
        </Animated.View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    position: 'relative',
  },
  tooltip: {
    position: 'absolute',
    bottom: '100%',
    left: '50%',
    transform: [{ translateX: -75 }], // Half of minWidth
    backgroundColor: '#0F172A',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 6,
    minWidth: 150,
    maxWidth: 250,
    marginBottom: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.15,
    shadowRadius: 8,
    elevation: 5,
    zIndex: 1000,
  },
  tooltipText: {
    color: '#F8FAFC',
    fontSize: 12,
    lineHeight: 16,
    textAlign: 'center',
  },
  arrow: {
    position: 'absolute',
    bottom: -6,
    left: '50%',
    marginLeft: -6,
    width: 0,
    height: 0,
    borderLeftWidth: 6,
    borderRightWidth: 6,
    borderTopWidth: 6,
    borderLeftColor: 'transparent',
    borderRightColor: 'transparent',
    borderTopColor: '#0F172A',
  },
});
```

**Step 2: Run tests to verify they pass**

Run: `pnpm --filter klard-mobile test src/__tests__/components/ui/Tooltip.test.tsx --run`
Expected: Most tests should PASS

**Step 3: Fix any failing tests and refactor**

Review test output and adjust component as needed.

**Step 4: Commit**

```bash
git add klard-mobile/src/components/ui/Tooltip.tsx klard-mobile/src/__tests__/components/ui/Tooltip.test.tsx
git commit -m "feat(mobile): add tooltip component with tests"
```

---

### Task 8: Export Mobile Tooltip from Index

**Files:**
- Modify: `klard-mobile/src/components/ui/index.ts`

**Step 1: Add export statement**

Add to `klard-mobile/src/components/ui/index.ts`:

```tsx
export { Tooltip, type TooltipProps } from './Tooltip';
```

**Step 2: Run TypeScript check**

Run: `pnpm --filter klard-mobile exec tsc --noEmit`
Expected: No errors

**Step 3: Commit**

```bash
git add klard-mobile/src/components/ui/index.ts
git commit -m "feat(mobile): export tooltip from ui index"
```

---

### Task 9: Final Web Verification

**Files:**
- N/A (verification only)

**Step 1: Run all web tooltip tests**

Run: `pnpm --filter klard-web test src/__tests__/components/ui/tooltip.test.tsx --run`
Expected: All PASS

**Step 2: Run TypeScript check**

Run: `pnpm --filter klard-web exec tsc --noEmit`
Expected: No errors

**Step 3: Run lint**

Run: `pnpm --filter klard-web lint`
Expected: No errors

---

### Task 10: Final Mobile Verification

**Files:**
- N/A (verification only)

**Step 1: Run all mobile tooltip tests**

Run: `pnpm --filter klard-mobile test src/__tests__/components/ui/Tooltip.test.tsx --run`
Expected: All PASS

**Step 2: Run TypeScript check**

Run: `pnpm --filter klard-mobile exec tsc --noEmit`
Expected: No errors

---

### Task 11: Mark Component as Done

**Files:**
- Modify: `docs/screens/batch/Klard_Component_Specifications.md`

**Step 1: Update spec marker**

Change:
```
<!-- IN-PROGRESS:4.5-tooltip -->
```
To:
```
<!-- DONE:4.5-tooltip -->
```

**Step 2: Commit**

```bash
git add docs/screens/batch/Klard_Component_Specifications.md
git commit -m "docs: mark 4.5-tooltip as done"
```

---

### Task 12: Final Commit (All Changes)

**Step 1: Verify all changes are staged**

```bash
git status
```

**Step 2: Create final feature commit if needed**

```bash
git add -A
git commit -m "feat: add tooltip component for web and mobile platforms

- Web: shadcn/ui Tooltip with TooltipWrapper convenience component
- Mobile: Custom Tooltip with long-press, haptics, and auto-hide
- Full test coverage for both platforms
- Accessible with screen reader support"
```

---

## Verification Checklist

Before marking complete, verify:

- [ ] Web Tooltip component renders without errors
- [ ] Mobile Tooltip component renders without errors
- [ ] All props implemented and typed (content, side, duration, disabled)
- [ ] All required states functional (hidden, visible, disabled)
- [ ] Matches design specification (dark tooltip on light bg)
- [ ] Accessibility attributes included (role=tooltip, aria-live)
- [ ] TypeScript passes: `pnpm --filter klard-web exec tsc --noEmit`
- [ ] TypeScript passes: `pnpm --filter klard-mobile exec tsc --noEmit`
- [ ] All Web tests passing: `pnpm --filter klard-web test src/__tests__/components/ui/tooltip.test.tsx --run`
- [ ] All Mobile tests passing: `pnpm --filter klard-mobile test src/__tests__/components/ui/Tooltip.test.tsx --run`
- [ ] Web component exported from `components/ui/index.ts`
- [ ] Mobile component exported from `components/ui/index.ts`
- [ ] Spec marker updated to `<!-- DONE:4.5-tooltip -->`

---

## Dependencies

**Web:**
- `@radix-ui/react-tooltip` (installed with shadcn/ui)

**Mobile:**
- `expo-haptics` (already in project)

No additional packages need to be installed.