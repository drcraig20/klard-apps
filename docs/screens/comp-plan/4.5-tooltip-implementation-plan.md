# Tooltip Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Deliver a cross-platform Tooltip that provides contextual help on hover/focus (web) and long-press (mobile) with configurable placement, timing, animation, callbacks, and accessibility that matches Klard design tokens.

**Architecture:**
- **Web:** Wrap shadcn/ui `TooltipProvider` + `Tooltip` primitives. Controlled via `side`, `align`, `delayDuration`, `className`, `asChild`. Data-slot tags for trigger/content. Default delay ~150ms, fade/scale entry, Radix-managed aria, optional custom className.
- **Mobile:** Pressable trigger with long-press to reveal bubble; `expo-haptics` feedback; opacity/scale animation; auto-hide timeout; configurable duration; optional callbacks (onShow/onHide); absolute-position overlay with arrow indicator; timer cleanup on unmount; AccessibilityInfo announcements for screen readers.

**Tech Stack:** Next.js 16 App Router, React 19, Tailwind 4, shadcn/ui Tooltip, `cn`, Vitest + Testing Library (web). Expo SDK 54, React Native, `expo-haptics`, `Animated`/`StyleSheet`/`Pressable`/`View`/`Text`, React Native Testing Library (mobile).

---

## Props Interface

**Web Tooltip (TooltipWrapper):**
```ts
interface TooltipWrapperProps {
  content: React.ReactNode;
  children: React.ReactNode;
  side?: "top" | "bottom" | "left" | "right";
  sideOffset?: number;
  delayDuration?: number;
  className?: string;
}
```

**Mobile Tooltip:**
```ts
interface TooltipProps {
  /** Content to display in the tooltip */
  content: React.ReactNode;
  /** Trigger element */
  children: React.ReactNode;
  /** Duration in ms before tooltip auto-hides (default: 2000) */
  duration?: number;
  /** Disable tooltip interaction */
  disabled?: boolean;
  /** Callback when tooltip shows */
  onShow?: () => void;
  /** Callback when tooltip hides */
  onHide?: () => void;
  /** Test ID for testing */
  testID?: string;
  /** Accessibility label for trigger */
  accessibilityLabel?: string;
  /** Custom styles for tooltip container */
  style?: ViewStyle;
  /** Custom styles for tooltip text */
  textStyle?: TextStyle;
}
```

## Visual States

- **Hidden â†’ visible** on hover/focus (web) or long-press (mobile)
- **Fade/scale animation** on show/hide
- **Auto-hide** on blur/mouse leave (web), after timeout (mobile)
- **Focus-visible state** on trigger
- **Disabled state** (mobile only) prevents showing tooltip
- **Arrow indicator** (mobile) points to trigger element

## Size/Position

- **Web:** Default padding `px-3 py-2` with `rounded-md`. Positioning via Radix `side/align` props. Custom className support.
- **Mobile:** Default padding `px-3 py-2` (12/8 StyleSheet units), `borderRadius: 6`, `minWidth: 150`, `maxWidth: 250`. Absolute positioning with centered arrow. Custom style/textStyle support.

## Colors/Tokens (Klard Design System)

- **Background:** `#0F172A` (slate-900 dark)
- **Text:** `#F8FAFC` (slate-50 light)
- **Shadow:** `shadow-md` with `shadowOpacity: 0.15`, `shadowRadius: 8`
- **Arrow:** (mobile only) `#0F172A` matching background

## Accessibility

**Web:**
- Radix manages `aria-describedby` automatically
- Include `TooltipProvider` at root
- Support `asChild` to avoid wrapper spans
- Add `data-slot="tooltip"` and `data-slot="tooltip.trigger"`
- Keyboard focus shows tooltip

**Mobile:**
- Bubble has `accessibilityRole="alert"` and `accessibilityLiveRegion="polite"`
- Trigger has `accessibilityRole="button"` and `accessibilityHint="Long press to show tooltip"`
- `AccessibilityInfo.announceForAccessibility()` for screen readers
- Optional `accessibilityLabel` on trigger
- Haptics optional but should not throw if unavailable

## Dependencies

- **Web:** shadcn/ui Tooltip, `@radix-ui/react-tooltip`, `cn`
- **Mobile:** `expo-haptics`, `Animated`, `StyleSheet`, `Pressable`, `View`, `Text`, `AccessibilityInfo`

## SOLID Compliance

| Component | SRP | OCP | LSP | ISP | DIP |
|-----------|-----|-----|-----|-----|-----|
| Tooltip (Web) | Renders tooltip only, manages display around trigger | Extensible via side/align/className props without modifying core | Handles all trigger types consistently | Single focused TooltipWrapperProps interface | Depends on Radix/TooltipProps abstractions |
| Tooltip (Mobile) | Manages tooltip visibility, long-press interaction, haptics | Timing/placement/callbacks tunable via props without modification | Same prop contract works for all children types | Minimal interface with only necessary props | Depends on haptics/timer/animation abstractions |

### Principle Applications

**SRP (Single Responsibility Principle):** Each component has one job - display contextual help on interaction. Web delegates to Radix primitives; Mobile manages state/animation/haptics internally.

**OCP (Open/Closed Principle):** Positioning, styling, timing, and behavior are extensible via props (side, className, duration, callbacks) without modifying component code.

**LSP (Liskov Substitution Principle):** All prop combinations work consistently. Any valid React node works as trigger/content. TooltipWrapper (web) simplifies API but maintains compatibility.

**ISP (Interface Segregation Principle):** Props are minimal and focused. Web props focus on positioning/styling. Mobile props add interaction controls (duration, disabled, callbacks). No forced dependencies on unused props.

**DIP (Dependency Inversion Principle):** Components depend on abstractions (TooltipProps interface, Radix primitives, expo-haptics API) not concrete implementations. Easy to swap animation/haptic strategies.

---

## Parallel Sub-Agent Strategy

**Task Groups for Parallel Execution:**
- **Group A (Web):** Tasks 1-2 (Web tests + implementation)
- **Group B (Mobile):** Tasks 3-4 (Mobile tests + implementation)
- **Group C (Final):** Task 5 (Verification and spec update)

Groups A and B can run in parallel. Group C runs after both complete.

---

## Test Strategy (TDD)

**Web Tests:**
- Rendering: children intact, no initial content
- Hover: shows content on hover, hides on mouse leave
- Focus: shows on keyboard focus
- Positioning: side prop sets `data-side` attribute (top/bottom/left/right)
- Custom className merges with defaults
- TooltipWrapper: simplified API works with side/delayDuration props
- Data-slot attributes present
- Accessibility: role="tooltip" when visible

**Mobile Tests:**
- Rendering: children visible, no initial tooltip, testID support
- Long Press: shows on long-press, triggers haptic feedback
- Auto-hide: hides after duration (default 2000ms), respects custom duration
- Disabled: doesn't show when disabled, no haptics when disabled
- Content Types: string content, React node content
- Accessibility: accessibilityLabel on trigger, screen reader announcement
- Callbacks: onShow called when appears, onHide called when disappears
- Edge Cases: rapid long presses, empty content handling

---

## Tasks

### Task 1: Write failing web tests and implement web Tooltip

**Files:**
- Create: `klard-web/src/__tests__/components/ui/tooltip.test.tsx`
- Create: `klard-web/src/components/ui/tooltip.tsx` (via shadcn CLI)
- Modify: `klard-web/src/components/ui/tooltip.tsx` (customize)
- Modify: `klard-web/src/components/ui/index.ts`
- Test cmd: `pnpm --filter klard-web test src/__tests__/components/ui/tooltip.test.tsx --run`

**Step 1: Write the failing test**

Create `klard-web/src/__tests__/components/ui/tooltip.test.tsx`:

```tsx
/**
 * Tests for Tooltip Component (Web)
 *
 * TDD: Write failing tests first, then implement to pass.
 * Tests verify: rendering, positioning, content, accessibility
 */

import { describe, it, expect } from "vitest"
import { render, screen, waitFor } from "@testing-library/react"
import userEvent from "@testing-library/user-event"
import { Tooltip, TooltipContent, TooltipTrigger, TooltipProvider, TooltipWrapper } from "@/components/ui/tooltip"
import { Button } from "@/components/ui/button"

describe("Tooltip", () => {
  describe("Rendering", () => {
    it("should render trigger element", () => {
      render(
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent>Tooltip content</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      expect(screen.getByRole("button", { name: "Hover me" })).toBeInTheDocument()
    })

    it("should not show tooltip content initially", () => {
      render(
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent>Hidden content</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      expect(screen.queryByText("Hidden content")).not.toBeInTheDocument()
    })

    it("should show tooltip content on hover", async () => {
      const user = userEvent.setup()

      render(
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent>Tooltip content</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      await user.hover(screen.getByRole("button"))

      await waitFor(() => {
        expect(screen.getByRole("tooltip")).toBeInTheDocument()
        expect(screen.getByText("Tooltip content")).toBeInTheDocument()
      })
    })

    it("should hide tooltip on mouse leave", async () => {
      const user = userEvent.setup()

      render(
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent>Tooltip content</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      await user.hover(screen.getByRole("button"))
      await waitFor(() => {
        expect(screen.getByText("Tooltip content")).toBeInTheDocument()
      })

      await user.unhover(screen.getByRole("button"))
      await waitFor(() => {
        expect(screen.queryByText("Tooltip content")).not.toBeInTheDocument()
      })
    })
  })

  describe("Positioning", () => {
    it("should render with default top position", async () => {
      const user = userEvent.setup()

      render(
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent>Top tooltip</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      await user.hover(screen.getByRole("button"))

      await waitFor(() => {
        const tooltip = screen.getByRole("tooltip")
        expect(tooltip).toHaveAttribute("data-side", "top")
      })
    })

    it("should render with bottom position when specified", async () => {
      const user = userEvent.setup()

      render(
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent side="bottom">Bottom tooltip</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      await user.hover(screen.getByRole("button"))

      await waitFor(() => {
        const tooltip = screen.getByRole("tooltip")
        expect(tooltip).toHaveAttribute("data-side", "bottom")
      })
    })

    it("should render with left position when specified", async () => {
      const user = userEvent.setup()

      render(
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent side="left">Left tooltip</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      await user.hover(screen.getByRole("button"))

      await waitFor(() => {
        const tooltip = screen.getByRole("tooltip")
        expect(tooltip).toHaveAttribute("data-side", "left")
      })
    })

    it("should render with right position when specified", async () => {
      const user = userEvent.setup()

      render(
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent side="right">Right tooltip</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      await user.hover(screen.getByRole("button"))

      await waitFor(() => {
        const tooltip = screen.getByRole("tooltip")
        expect(tooltip).toHaveAttribute("data-side", "right")
      })
    })
  })

  describe("Content", () => {
    it("should render string content", async () => {
      const user = userEvent.setup()

      render(
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent>Simple text</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      await user.hover(screen.getByRole("button"))

      await waitFor(() => {
        expect(screen.getByText("Simple text")).toBeInTheDocument()
      })
    })

    it("should render complex content", async () => {
      const user = userEvent.setup()

      render(
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent>
              <div>
                <strong>Title</strong>
                <p>Description text</p>
              </div>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      await user.hover(screen.getByRole("button"))

      await waitFor(() => {
        expect(screen.getByText("Title")).toBeInTheDocument()
        expect(screen.getByText("Description text")).toBeInTheDocument()
      })
    })
  })

  describe("Accessibility", () => {
    it("should have role tooltip when visible", async () => {
      const user = userEvent.setup()

      render(
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent>Accessible tooltip</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      await user.hover(screen.getByRole("button"))

      await waitFor(() => {
        expect(screen.getByRole("tooltip")).toBeInTheDocument()
      })
    })

    it("should show tooltip on focus", async () => {
      const user = userEvent.setup()

      render(
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Focus me</Button>
            </TooltipTrigger>
            <TooltipContent>Focus tooltip</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      await user.tab()

      await waitFor(() => {
        expect(screen.getByRole("tooltip")).toBeInTheDocument()
      })
    })
  })

  describe("Custom className", () => {
    it("should merge custom className with default classes", async () => {
      const user = userEvent.setup()

      render(
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent className="custom-tooltip">Content</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      await user.hover(screen.getByRole("button"))

      await waitFor(() => {
        const tooltip = screen.getByRole("tooltip")
        expect(tooltip.className).toContain("custom-tooltip")
      })
    })
  })

  describe("sideOffset", () => {
    it("should apply sideOffset prop", async () => {
      const user = userEvent.setup()

      render(
        <TooltipProvider delayDuration={0}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button>Hover me</Button>
            </TooltipTrigger>
            <TooltipContent sideOffset={10}>Offset tooltip</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )

      await user.hover(screen.getByRole("button"))

      await waitFor(() => {
        expect(screen.getByRole("tooltip")).toBeInTheDocument()
      })
    })
  })

  describe("TooltipWrapper", () => {
    it("should render with simplified API", async () => {
      const user = userEvent.setup()

      render(
        <TooltipWrapper content="Wrapper tooltip" delayDuration={0}>
          <Button>Simple trigger</Button>
        </TooltipWrapper>
      )

      await user.hover(screen.getByRole("button"))

      await waitFor(() => {
        expect(screen.getByText("Wrapper tooltip")).toBeInTheDocument()
      })
    })

    it("should accept side prop", async () => {
      const user = userEvent.setup()

      render(
        <TooltipWrapper content="Bottom tooltip" side="bottom" delayDuration={0}>
          <Button>Trigger</Button>
        </TooltipWrapper>
      )

      await user.hover(screen.getByRole("button"))

      await waitFor(() => {
        const tooltip = screen.getByRole("tooltip")
        expect(tooltip).toHaveAttribute("data-side", "bottom")
      })
    })

    it("should accept delayDuration prop", async () => {
      const user = userEvent.setup()

      render(
        <TooltipWrapper content="Delayed tooltip" delayDuration={0}>
          <Button>Trigger</Button>
        </TooltipWrapper>
      )

      await user.hover(screen.getByRole("button"))

      await waitFor(() => {
        expect(screen.getByText("Delayed tooltip")).toBeInTheDocument()
      })
    })
  })
})
```

**Step 2: Run test to verify it fails**

Run: `pnpm --filter klard-web test src/__tests__/components/ui/tooltip.test.tsx --run`

Expected: FAIL - Tooltip component doesn't exist yet

**Step 3: Install shadcn/ui tooltip**

Run: `cd klard-web && npx shadcn@latest add tooltip`

**Step 4: Customize for Klard design system**

Modify `klard-web/src/components/ui/tooltip.tsx`:

```tsx
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ComponentRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Portal>
    <TooltipPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 overflow-hidden rounded-md bg-[#0F172A] px-3 py-1.5 text-xs text-[#F8FAFC] animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 dark:bg-[#F8FAFC] dark:text-[#0F172A]",
        className
      )}
      data-slot="tooltip"
      {...props}
    />
  </TooltipPrimitive.Portal>
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export interface TooltipWrapperProps {
  content: React.ReactNode
  children: React.ReactNode
  side?: "top" | "bottom" | "left" | "right"
  sideOffset?: number
  delayDuration?: number
  className?: string
}

const TooltipWrapper = ({
  content,
  children,
  side = "top",
  sideOffset = 4,
  delayDuration = 200,
  className,
}: TooltipWrapperProps) => (
  <TooltipProvider delayDuration={delayDuration}>
    <Tooltip>
      <TooltipTrigger asChild>{children}</TooltipTrigger>
      <TooltipContent side={side} sideOffset={sideOffset} className={className}>
        {content}
      </TooltipContent>
    </Tooltip>
  </TooltipProvider>
)

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider, TooltipWrapper }
```

**Step 5: Run test to verify it passes**

Run: `pnpm --filter klard-web test src/__tests__/components/ui/tooltip.test.tsx --run`

Expected: PASS

**Step 6: Export from index**

Add to `klard-web/src/components/ui/index.ts`:

```tsx
export {
  Tooltip,
  TooltipTrigger,
  TooltipContent,
  TooltipProvider,
  TooltipWrapper,
  type TooltipWrapperProps,
} from './tooltip';
```

**Step 7: Commit**

```bash
git add klard-web/src/components/ui/tooltip.tsx klard-web/src/__tests__/components/ui/tooltip.test.tsx klard-web/src/components/ui/index.ts
git commit -m "feat(web): add tooltip component with tests"
```

---

### Task 2: Final web verification

**Files:**
- N/A (verification only)

**Step 1: Run all web tooltip tests**

Run: `pnpm --filter klard-web test src/__tests__/components/ui/tooltip.test.tsx --run`

Expected: All PASS

**Step 2: Run TypeScript check**

Run: `pnpm --filter klard-web exec tsc --noEmit`

Expected: No errors

---

### Task 3: Write failing mobile tests and implement mobile Tooltip

**Files:**
- Create: `klard-mobile/src/__tests__/components/ui/Tooltip.test.tsx`
- Create: `klard-mobile/src/components/ui/Tooltip.tsx`
- Modify: `klard-mobile/src/components/ui/index.ts`
- Test cmd: `pnpm --filter klard-mobile test src/__tests__/components/ui/Tooltip.test.tsx --run`

**Step 1: Write the failing test**

Create `klard-mobile/src/__tests__/components/ui/Tooltip.test.tsx`:

```tsx
/**
 * Tests for Tooltip Component (Mobile)
 *
 * TDD: Write failing tests first, then implement to pass.
 */

import React from 'react';
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react-native';
import { Text, View } from 'react-native';
import { Tooltip } from '@/components/ui/Tooltip';
import * as Haptics from 'expo-haptics';

// Mock expo-haptics
jest.mock('expo-haptics', () => ({
  impactAsync: jest.fn(),
  ImpactFeedbackStyle: {
    Light: 'light',
    Medium: 'medium',
    Heavy: 'heavy',
  },
}));

// Mock Animated to avoid timing issues in tests
jest.mock('react-native', () => {
  const RN = jest.requireActual('react-native');
  RN.Animated.timing = () => ({
    start: (callback?: () => void) => callback?.(),
  });
  return RN;
});

describe('Tooltip', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    jest.useFakeTimers();
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  describe('Rendering', () => {
    it('should render children', () => {
      render(
        <Tooltip content="Tooltip text">
          <Text>Trigger</Text>
        </Tooltip>
      );

      expect(screen.getByText('Trigger')).toBeTruthy();
    });

    it('should not show tooltip content initially', () => {
      render(
        <Tooltip content="Hidden content">
          <Text>Trigger</Text>
        </Tooltip>
      );

      expect(screen.queryByText('Hidden content')).toBeNull();
    });

    it('should have correct testID when provided', () => {
      render(
        <Tooltip content="Content" testID="my-tooltip">
          <Text>Trigger</Text>
        </Tooltip>
      );

      expect(screen.getByTestId('my-tooltip')).toBeTruthy();
    });
  });

  describe('Long Press Interaction', () => {
    it('should show tooltip on long press', async () => {
      render(
        <Tooltip content="Visible content">
          <Text>Press and hold</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Press and hold');

      await act(async () => {
        fireEvent(trigger, 'longPress');
      });

      expect(screen.getByText('Visible content')).toBeTruthy();
    });

    it('should trigger haptic feedback on long press', async () => {
      render(
        <Tooltip content="Haptic tooltip">
          <Text>Trigger</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Trigger');

      await act(async () => {
        fireEvent(trigger, 'longPress');
      });

      expect(Haptics.impactAsync).toHaveBeenCalledWith(
        Haptics.ImpactFeedbackStyle.Light
      );
    });

    it('should hide tooltip after duration', async () => {
      render(
        <Tooltip content="Disappearing content" duration={2000}>
          <Text>Trigger</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Trigger');

      await act(async () => {
        fireEvent(trigger, 'longPress');
      });

      expect(screen.getByText('Disappearing content')).toBeTruthy();

      await act(async () => {
        jest.advanceTimersByTime(2000);
      });

      expect(screen.queryByText('Disappearing content')).toBeNull();
    });

    it('should use default duration of 2000ms', async () => {
      render(
        <Tooltip content="Default duration">
          <Text>Trigger</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Trigger');

      await act(async () => {
        fireEvent(trigger, 'longPress');
      });

      expect(screen.getByText('Default duration')).toBeTruthy();

      // Should still be visible at 1900ms
      await act(async () => {
        jest.advanceTimersByTime(1900);
      });
      expect(screen.getByText('Default duration')).toBeTruthy();

      // Should be hidden at 2000ms
      await act(async () => {
        jest.advanceTimersByTime(100);
      });
      expect(screen.queryByText('Default duration')).toBeNull();
    });
  });

  describe('Content Types', () => {
    it('should render string content', async () => {
      render(
        <Tooltip content="String content">
          <Text>Trigger</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Trigger');

      await act(async () => {
        fireEvent(trigger, 'longPress');
      });

      expect(screen.getByText('String content')).toBeTruthy();
    });

    it('should render React node content', async () => {
      render(
        <Tooltip
          content={
            <View testID="complex-content">
              <Text>Complex</Text>
            </View>
          }
        >
          <Text>Trigger</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Trigger');

      await act(async () => {
        fireEvent(trigger, 'longPress');
      });

      expect(screen.getByTestId('complex-content')).toBeTruthy();
      expect(screen.getByText('Complex')).toBeTruthy();
    });
  });

  describe('Accessibility', () => {
    it('should have accessible label on trigger', () => {
      render(
        <Tooltip content="Help text" accessibilityLabel="Show help">
          <Text>?</Text>
        </Tooltip>
      );

      expect(screen.getByLabelText('Show help')).toBeTruthy();
    });

    it('should announce tooltip content to screen reader', async () => {
      render(
        <Tooltip content="Screen reader content">
          <Text>Trigger</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Trigger');

      await act(async () => {
        fireEvent(trigger, 'longPress');
      });

      const tooltip = screen.getByText('Screen reader content');
      expect(tooltip).toBeTruthy();
    });
  });

  describe('Disabled State', () => {
    it('should not show tooltip when disabled', async () => {
      render(
        <Tooltip content="Disabled content" disabled>
          <Text>Trigger</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Trigger');

      await act(async () => {
        fireEvent(trigger, 'longPress');
      });

      expect(screen.queryByText('Disabled content')).toBeNull();
    });

    it('should not trigger haptics when disabled', async () => {
      render(
        <Tooltip content="No haptics" disabled>
          <Text>Trigger</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Trigger');

      await act(async () => {
        fireEvent(trigger, 'longPress');
      });

      expect(Haptics.impactAsync).not.toHaveBeenCalled();
    });
  });

  describe('Callbacks', () => {
    it('should call onShow when tooltip appears', async () => {
      const onShow = jest.fn();

      render(
        <Tooltip content="Callback test" onShow={onShow}>
          <Text>Trigger</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Trigger');

      await act(async () => {
        fireEvent(trigger, 'longPress');
      });

      expect(onShow).toHaveBeenCalledTimes(1);
    });

    it('should call onHide when tooltip disappears', async () => {
      const onHide = jest.fn();

      render(
        <Tooltip content="Hide callback" duration={1000} onHide={onHide}>
          <Text>Trigger</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Trigger');

      await act(async () => {
        fireEvent(trigger, 'longPress');
      });

      expect(onHide).not.toHaveBeenCalled();

      await act(async () => {
        jest.advanceTimersByTime(1000);
      });

      expect(onHide).toHaveBeenCalledTimes(1);
    });
  });

  describe('Edge Cases', () => {
    it('should handle rapid long presses', async () => {
      render(
        <Tooltip content="Rapid press test" duration={500}>
          <Text>Trigger</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Trigger');

      // First long press
      await act(async () => {
        fireEvent(trigger, 'longPress');
      });
      expect(screen.getByText('Rapid press test')).toBeTruthy();

      // Second long press before timeout
      await act(async () => {
        jest.advanceTimersByTime(200);
        fireEvent(trigger, 'longPress');
      });

      // Should still be visible
      expect(screen.getByText('Rapid press test')).toBeTruthy();
    });

    it('should handle empty content gracefully', async () => {
      render(
        <Tooltip content="">
          <Text>Trigger</Text>
        </Tooltip>
      );

      const trigger = screen.getByText('Trigger');

      await act(async () => {
        fireEvent(trigger, 'longPress');
      });

      // Should not crash, trigger still visible
      expect(screen.getByText('Trigger')).toBeTruthy();
    });
  });
});
```

**Step 2: Run test to verify it fails**

Run: `pnpm --filter klard-mobile test src/__tests__/components/ui/Tooltip.test.tsx --run`

Expected: FAIL - Tooltip component doesn't exist

**Step 3: Implement the component**

Create `klard-mobile/src/components/ui/Tooltip.tsx`:

```tsx
import React, { useState, useCallback, useRef, useEffect } from 'react';
import {
  View,
  Text,
  Pressable,
  StyleSheet,
  Animated,
  ViewStyle,
  TextStyle,
  AccessibilityInfo,
} from 'react-native';
import * as Haptics from 'expo-haptics';

export interface TooltipProps {
  /** Content to display in the tooltip */
  content: React.ReactNode;
  /** Trigger element */
  children: React.ReactNode;
  /** Duration in ms before tooltip auto-hides (default: 2000) */
  duration?: number;
  /** Disable tooltip interaction */
  disabled?: boolean;
  /** Callback when tooltip shows */
  onShow?: () => void;
  /** Callback when tooltip hides */
  onHide?: () => void;
  /** Test ID for testing */
  testID?: string;
  /** Accessibility label for trigger */
  accessibilityLabel?: string;
  /** Custom styles for tooltip container */
  style?: ViewStyle;
  /** Custom styles for tooltip text */
  textStyle?: TextStyle;
}

export function Tooltip({
  content,
  children,
  duration = 2000,
  disabled = false,
  onShow,
  onHide,
  testID,
  accessibilityLabel,
  style,
  textStyle,
}: TooltipProps) {
  const [visible, setVisible] = useState(false);
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const hideTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const clearHideTimeout = useCallback(() => {
    if (hideTimeoutRef.current) {
      clearTimeout(hideTimeoutRef.current);
      hideTimeoutRef.current = null;
    }
  }, []);

  const showTooltip = useCallback(() => {
    clearHideTimeout();
    setVisible(true);

    Animated.timing(fadeAnim, {
      toValue: 1,
      duration: 150,
      useNativeDriver: true,
    }).start();

    onShow?.();

    hideTimeoutRef.current = setTimeout(() => {
      hideTooltip();
    }, duration);
  }, [duration, onShow, fadeAnim, clearHideTimeout]);

  const hideTooltip = useCallback(() => {
    clearHideTimeout();

    Animated.timing(fadeAnim, {
      toValue: 0,
      duration: 150,
      useNativeDriver: true,
    }).start(() => {
      setVisible(false);
      onHide?.();
    });
  }, [onHide, fadeAnim, clearHideTimeout]);

  const handleLongPress = useCallback(async () => {
    if (disabled) return;

    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    showTooltip();

    // Announce to screen reader
    if (typeof content === 'string') {
      AccessibilityInfo.announceForAccessibility(content);
    }
  }, [disabled, content, showTooltip]);

  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      clearHideTimeout();
    };
  }, [clearHideTimeout]);

  const renderContent = () => {
    if (typeof content === 'string') {
      return <Text style={[styles.tooltipText, textStyle]}>{content}</Text>;
    }
    return content;
  };

  return (
    <View testID={testID} style={styles.container}>
      <Pressable
        onLongPress={handleLongPress}
        accessibilityLabel={accessibilityLabel}
        accessibilityRole="button"
        accessibilityHint="Long press to show tooltip"
      >
        {children}
      </Pressable>
      {visible && (
        <Animated.View
          style={[
            styles.tooltip,
            style,
            {
              opacity: fadeAnim,
              transform: [
                {
                  scale: fadeAnim.interpolate({
                    inputRange: [0, 1],
                    outputRange: [0.95, 1],
                  }),
                },
              ],
            },
          ]}
          accessibilityRole="alert"
          accessibilityLiveRegion="polite"
        >
          {renderContent()}
          <View style={styles.arrow} />
        </Animated.View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    position: 'relative',
  },
  tooltip: {
    position: 'absolute',
    bottom: '100%',
    left: '50%',
    transform: [{ translateX: -75 }], // Half of minWidth
    backgroundColor: '#0F172A',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 6,
    minWidth: 150,
    maxWidth: 250,
    marginBottom: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.15,
    shadowRadius: 8,
    elevation: 5,
    zIndex: 1000,
  },
  tooltipText: {
    color: '#F8FAFC',
    fontSize: 12,
    lineHeight: 16,
    textAlign: 'center',
  },
  arrow: {
    position: 'absolute',
    bottom: -6,
    left: '50%',
    marginLeft: -6,
    width: 0,
    height: 0,
    borderLeftWidth: 6,
    borderRightWidth: 6,
    borderTopWidth: 6,
    borderLeftColor: 'transparent',
    borderRightColor: 'transparent',
    borderTopColor: '#0F172A',
  },
});
```

**Step 4: Run test to verify it passes**

Run: `pnpm --filter klard-mobile test src/__tests__/components/ui/Tooltip.test.tsx --run`

Expected: PASS

**Step 5: Export from index**

Add to `klard-mobile/src/components/ui/index.ts`:

```tsx
export { Tooltip, type TooltipProps } from './Tooltip';
```

**Step 6: Commit**

```bash
git add klard-mobile/src/components/ui/Tooltip.tsx klard-mobile/src/__tests__/components/ui/Tooltip.test.tsx klard-mobile/src/components/ui/index.ts
git commit -m "feat(mobile): add tooltip component with tests"
```

---

### Task 4: Final mobile verification

**Files:**
- N/A (verification only)

**Step 1: Run all mobile tooltip tests**

Run: `pnpm --filter klard-mobile test src/__tests__/components/ui/Tooltip.test.tsx --run`

Expected: All PASS

**Step 2: Run TypeScript check**

Run: `pnpm --filter klard-mobile exec tsc --noEmit`

Expected: No errors

---

### Task 5: Verification and spec update

**Files:**
- Modify: `docs/screens/batch/Klard_Component_Specifications.md`

**Step 1: Run all verification commands**

Run the following commands and capture outputs:
- `pnpm --filter klard-web test src/__tests__/components/ui/tooltip.test.tsx --run`
- `pnpm --filter klard-web exec tsc --noEmit`
- `pnpm --filter klard-mobile test src/__tests__/components/ui/Tooltip.test.tsx --run`
- `pnpm --filter klard-mobile exec tsc --noEmit`

**Step 2: Update spec marker**

Change in `docs/screens/batch/Klard_Component_Specifications.md`:
```
<!-- IN-PROGRESS:4.5-tooltip -->
```
To:
```
<!-- DONE:4.5-tooltip -->
```

**Step 3: Final commit**

```bash
git add docs/screens/batch/Klard_Component_Specifications.md
git commit -m "docs: mark 4.5-tooltip as done"
```

---

## Verification Checklist

Before marking complete, verify:

- [ ] Web Tooltip component renders without errors
- [ ] Mobile Tooltip component renders without errors
- [ ] All props implemented and typed (content, side, align, delayDuration, duration, disabled, callbacks, testID, accessibilityLabel, style, textStyle)
- [ ] All required states functional (hidden, visible, disabled on mobile)
- [ ] Matches design specification (Klard tokens: #0F172A bg, #F8FAFC text)
- [ ] Accessibility attributes included (role=tooltip, aria-describedby, AccessibilityInfo announcements)
- [ ] Data-slot attributes on web (data-slot="tooltip")
- [ ] Haptic feedback works on mobile (expo-haptics)
- [ ] Auto-hide timing works correctly (web delay, mobile duration)
- [ ] Callbacks fire correctly (onShow, onHide on mobile)
- [ ] TypeScript passes: `pnpm --filter klard-web exec tsc --noEmit`
- [ ] TypeScript passes: `pnpm --filter klard-mobile exec tsc --noEmit`
- [ ] All Web tests passing: `pnpm --filter klard-web test src/__tests__/components/ui/tooltip.test.tsx --run`
- [ ] All Mobile tests passing: `pnpm --filter klard-mobile test src/__tests__/components/ui/Tooltip.test.tsx --run`
- [ ] Web component exported from `components/ui/index.ts`
- [ ] Mobile component exported from `components/ui/index.ts`
- [ ] Spec marker updated to `<!-- DONE:4.5-tooltip -->`

---

## Notes

- Web implementation uses shadcn/ui CLI for initial setup
- Mobile implementation is fully custom with expo-haptics integration
- Both platforms use exact Klard design tokens (#0F172A, #F8FAFC)
- Mobile includes arrow indicator; web does not (Radix default)
- Complete test coverage ensures TDD discipline throughout
